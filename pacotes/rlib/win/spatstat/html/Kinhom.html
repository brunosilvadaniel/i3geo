<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>R: Inhomogeneous K-function</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../R.css">
</head><body>

<table width="100%" summary="page for Kinhom {spatstat}"><tr><td>Kinhom {spatstat}</td><td align="right">R Documentation</td></tr></table>
<h2>Inhomogeneous K-function</h2>


<h3>Description</h3>

<p>
Estimates the inhomogeneous <i>K</i> function of
a non-stationary point pattern.
</p>


<h3>Usage</h3>

<pre>
  Kinhom(X, lambda, ..., r = NULL, breaks = NULL,
    correction=c("border", "bord.modif", "isotropic", "translate"),
    nlarge = 1000, lambda2, sigma=NULL, varcov=NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>X</code></td>
<td>
The observed data point pattern,
from which an estimate of the inhomogeneous <i>K</i> function
will be computed.
An object of class <code>"ppp"</code>
or in a format recognised by <code><a href="as.ppp.html">as.ppp</a>()</code>
</td></tr>
<tr valign="top"><td><code>lambda</code></td>
<td>
Optional.
Values of the estimated intensity function.
Either a vector giving the intensity values
at the points of the pattern <code>X</code>,
or a pixel image (object of class <code>"im"</code>) giving the
intensity values at all locations.
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
Extra arguments. Ignored if <code>lambda</code> is present.
Passed to <code><a href="density.ppp.html">density.ppp</a></code> if <code>lambda</code> is omitted.
</td></tr>
<tr valign="top"><td><code>r</code></td>
<td>
vector of values for the argument <i>r</i> at which
the inhomogeneous <i>K</i> function
should be evaluated. Not normally given by the user;
there is a sensible default.
</td></tr>
<tr valign="top"><td><code>breaks</code></td>
<td>
An alternative to the argument <code>r</code>.
Not normally invoked by the user.
See Details.
</td></tr>
<tr valign="top"><td><code>correction</code></td>
<td>
A character vector containing any selection of the
options <code>"border"</code>, <code>"bord.modif"</code>,
<code>"isotropic"</code>, <code>"Ripley"</code> or <code>"translate"</code>.
It specifies the edge correction(s) to be applied.
</td></tr>
<tr valign="top"><td><code>nlarge</code></td>
<td>
Optional. Efficiency threshold.
If the number of points exceeds <code>nlarge</code>, then only the
border correction will be computed, using a fast algorithm.
</td></tr>
<tr valign="top"><td><code>lambda2</code></td>
<td>
Advanced use only.
Matrix containing estimates of the products
<i>lambda(x[i]) * lambda(x[j])</i>
of the intensities at each pair of data points 
<i>x[i]</i> and <i>x[j]</i>. 
</td></tr>
<tr valign="top"><td><code>sigma,varcov</code></td>
<td>
Optional arguments passed to  <code><a href="density.ppp.html">density.ppp</a></code>
to control the smoothing bandwidth, when <code>lambda</code> is
estimated by kernel smoothing.
</td></tr>
</table>

<h3>Details</h3>

<p>
This computes a generalisation of the <i>K</i> function
for inhomogeneous point patterns, proposed by
Baddeley, Moller and Waagepetersen (2000).
</p>
<p>
The ``ordinary'' <i>K</i> function
(variously known as the reduced second order moment function
and Ripley's <i>K</i> function), is
described under <code><a href="Kest.html">Kest</a></code>. It is defined only
for stationary point processes.
</p>
<p>
The inhomogeneous <i>K</i> function
<i>Kinhom(r)</i>
is a direct generalisation to nonstationary point processes.
Suppose <i>x</i> is a point process with non-constant intensity
<i>lambda(u)</i> at each location <i>u</i>.
Define <i>Kinhom(r)</i> to be the expected
value, given that <i>u</i> is a point of <i>x</i>,
of the sum of all terms
<i>1/lambda(u)lambda(x[j])</i>
over all points <i>x[j]</i>
in the process separated from <i>u</i> by a distance less than <i>r</i>.
This reduces to the ordinary <i>K</i> function if
<i>lambda()</i> is constant.
If <i>x</i> is an inhomogeneous Poisson process with intensity
function <i>lambda(u)</i>, then
<i>Kinhom(r) = pi * r^2</i>.
</p>
<p>
This allows us to inspect a point pattern for evidence of 
interpoint interactions after allowing for spatial inhomogeneity
of the pattern. Values 
<i>Kinhom(r) &gt; pi * r^2</i>
are suggestive of clustering.
</p>
<p>
The argument <code>lambda</code> should supply the
(estimated) values of the intensity function <i>lambda</i>.
It may be either
<dl>
<dt>a numeric vector</dt><dd>containing the values
of the intensity function at the points of the pattern <code>X</code>.
The length of the vector <code>lambda</code> should
be equal to the number of points in the pattern <code>X</code>.
The value <code>lambda[i]</code> is assumed to be the 
the (estimated) value of the intensity
<i>lambda(x[i])</i> for
the point <i>x[i]</i> of the pattern <i>X</i>.
</dd>
<dt>a pixel image</dt><dd>(object of class <code>"im"</code>)
assumed to contain the values of the intensity function
at all locations in the window.
</dd>
</dl>
<p>
If <code>lambda</code> is omitted, then it will be estimated using
a `leave-one-out' kernel smoother, as described in
Baddeley et al (2000). The estimate <code>lambda[i]</code> for the
point <code>X[i]</code> is computed by removing <code>X[i]</code> from the
point pattern, applying kernel smoothing to the remaining points using
<code><a href="density.ppp.html">density.ppp</a></code>, and evaluating the smoothed intensity
at the point <code>X[i]</code>. The smoothing kernel bandwidth is controlled
by the arguments <code>sigma</code> and <code>varcov</code>, which are passed to
<code><a href="density.ppp.html">density.ppp</a></code> along with any extra arguments.
</p>
<p>
Edge corrections are used to correct bias in the estimation
of <i>Kinhom</i>.
Each edge-corrected estimate of <i>Kinhom(r)</i> is
of the form
</p><p align="center"><i>K^inhom(r)= sum[i] sum[j] 1(d[i,j] &lt;= r) * 
e(x[i],x[j],r)/(lambda(x[i]) * lambda(x[j]))
</i></p><p>
where <i>d[i,j]</i> is the distance between points
<i>x[i]</i> and <i>x[j]</i>, and
<i>e(x[i],x[j],r)</i> is
an edge correction factor. For the `border' correction,
</p><p align="center"><i>1(b[i] &gt; r)/(sum[j] 1(b[j] &gt; r)/lambda(x[j]))
</i></p><p>
where <i>b[i]</i> is the distance from <i>x[i]</i>
to the boundary of the window. For the `modified border'
correction, 
</p><p align="center"><i>1(b[i] &gt; r)/area(W [-] r)
</i></p><p>
where <i>W [-] r</i> is the eroded window obtained
by trimming a margin of width <i>r</i> from the border of the original
window.
For the `translation' correction,
</p><p align="center"><i>1/area(W intersect (W + x[j]-x[i]))
</i></p><p>
and for the `isotropic' correction,
</p><p align="center"><i>1/(area(W) g(x[i],x[j]))
</i></p><p>
where <i>g(x[i],x[j])</i> is the fraction of the
circumference of the circle with centre <i>x[i]</i> and radius
<i>||x[i]-x[j]||</i> which lies inside the window.
</p>
<p>
If the point pattern <code>X</code> contains more than about 1000 points,
the isotropic and translation edge corrections can be computationally
prohibitive. The computations for the border method are much faster,
and are statistically efficient when there are large numbers of
points. Accordingly, if the number of points in <code>X</code> exceeds
the threshold <code>nlarge</code>, then only the border correction will be
computed. Setting <code>nlarge=Inf</code> will prevent this from happening.
Setting <code>nlarge=0</code> is equivalent to selecting only the border
correction with <code>correction="border"</code>.
</p>
<p>
The pair correlation function can also be applied to the
result of <code>Kinhom</code>; see <code><a href="pcf.html">pcf</a></code>.
</p>


<h3>Value</h3>

<p>
An object of class <code>"fv"</code> (see <code><a href="fv.object.html">fv.object</a></code>).
<br>
Essentially a data frame containing at least the following columns,
</p>
<table summary="R argblock">
<tr valign="top"><td><code>r</code></td>
<td>
the vector of values of the argument <i>r</i> 
at which the pair correlation function <i>g(r)</i> has been  estimated
</td></tr>
<tr valign="top"><td><code>theo</code></td>
<td>
vector of values of <i>pi * r^2</i>,
the theoretical value of <i>Kinhom(r)</i>
for an inhomogeneous Poisson process
</td></tr>
</table>
<p>

and containing additional columns
according to the choice specified in the <code>correction</code>
argument. The additional columns are named
<code>border</code>, <code>trans</code> and <code>iso</code>
and give the estimated values of 
<i>Kinhom(r)</i>
using the border correction, translation correction,
and Ripley isotropic correction, respectively.</p>

<h3>Author(s)</h3>

<p>
Adrian Baddeley
<a href="mailto:adrian@maths.uwa.edu.au">adrian@maths.uwa.edu.au</a>
<a href="http://www.maths.uwa.edu.au/~adrian/">http://www.maths.uwa.edu.au/~adrian/</a>
and Rolf Turner
<a href="mailto:rolf@math.unb.ca">rolf@math.unb.ca</a>
<a href="http://www.math.unb.ca/~rolf">http://www.math.unb.ca/~rolf</a>
</p>


<h3>References</h3>

<p>
Baddeley, A., Moller, J. and Waagepetersen, R. (2000)
Non- and semiparametric estimation of interaction in
inhomogeneous point patterns.
<EM>Statistica Neerlandica</EM> <B>54</B>, 329&ndash;350.
</p>


<h3>See Also</h3>

<p>
<code><a href="Kest.html">Kest</a></code>,
<code><a href="pcf.html">pcf</a></code>
</p>


<h3>Examples</h3>

<pre>
  data(lansing)
  # inhomogeneous pattern of maples
  X &lt;- unmark(split(lansing)$maple)
  

  # (1) intensity function estimated by model-fitting
  # Fit spatial trend: polynomial in x and y coordinates
  fit &lt;- ppm(X, ~ polynom(x,y,2), Poisson())
  # predict intensity values at points themselves
  lambda &lt;- predict(fit, locations=X, type="trend")
  # inhomogeneous K function
  Ki &lt;- Kinhom(X, lambda)
  plot(Ki)

  # (2) intensity function estimated by heavy smoothing
  Ki &lt;- Kinhom(X, sigma=0.1)
  plot(Ki)

  # (3) simulated data: known intensity function
  lamfun &lt;- function(x,y) { 50 + 100 * x }
  # inhomogeneous Poisson process
  Y &lt;- rpoispp(lamfun, 150, owin())
  # evaluate intensity at points of pattern
  lambda &lt;- lamfun(Y$x, Y$y)
  # inhomogeneous K function
  Ki &lt;- Kinhom(Y, lambda)
  plot(Ki)

  # How to make simulation envelopes:
  #      Example shows method (2)
  ## Not run: 
  smo &lt;- density.ppp(X, sigma=0.1)
  Ken &lt;- envelope(X, Kinhom, nsim=99,
                  simulate=expression(rpoispp(smo)),
                  sigma=0.1, correction="trans")
  plot(Ken)
  
## End(Not run)
</pre>



<hr><div align="center">[Package <em>spatstat</em> version 1.10-3 <a href="00Index.html">Index]</a></div>

</body></html>
