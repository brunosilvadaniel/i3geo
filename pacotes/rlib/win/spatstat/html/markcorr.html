<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>R: Mark Correlation Function</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../R.css">
</head><body>

<table width="100%" summary="page for markcorr {spatstat}"><tr><td>markcorr {spatstat}</td><td align="right">R Documentation</td></tr></table>
<h2>Mark Correlation Function</h2>


<h3>Description</h3>

<p>
Estimate the marked correlation function
of a marked point pattern.
</p>


<h3>Usage</h3>

<pre>
markcorr(X, f = function(m1, m2) { m1 * m2}, r=NULL,
         correction=c("isotropic", "Ripley", "translate"),
         method="density", ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>X</code></td>
<td>
The observed point pattern.
An object of class <code>"ppp"</code> or something acceptable to
<code><a href="as.ppp.html">as.ppp</a></code>. 
</td></tr>
<tr valign="top"><td><code>f</code></td>
<td>
Function <i>f</i> used in the definition of the
mark correlation function. There is a sensible default
that depends on the kind of marks in <code>X</code>.
</td></tr>
<tr valign="top"><td><code>r</code></td>
<td>
numeric vector. The values of the argument <i>r</i>
at which the mark correlation function 
<i>rho_f(r)</i>
should be evaluated.
There is a sensible default.
</td></tr>
<tr valign="top"><td><code>correction</code></td>
<td>
A character vector containing any selection of the
options <code>"isotropic"</code>, <code>"Ripley"</code> or <code>"translate"</code>.
It specifies the edge correction(s) to be applied.
</td></tr>
<tr valign="top"><td><code>method</code></td>
<td>
A character vector indicating the user's choice of
density estimation technique to be used. Options are
<code>"density"</code>, 
<code>"loess"</code>,
<code>"sm"</code> and <code>"smrep"</code>.
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
Arguments passed to the density estimation routine
(<code><a href="../../stats/html/density.html">density</a></code>, <code><a href="../../stats/html/loess.html">loess</a></code> or <code>sm.density</code>)
selected by <code>method</code>.
</td></tr>
</table>

<h3>Details</h3>

<p>
The mark correlation function <i>rho_f(r)</i>
of a marked point process <i>X</i>
is a measure of the dependence between the marks of two 
points of the process a distance <i>r</i> apart.
It is informally defined as
</p><p align="center"><i>rho_f(r) = E[f(M1,M2)]/E[f(M,M')]
</i></p><p>
where <i>E[ ]</i> denotes expectation and <i>M1,M2</i>
are the marks attached to two points of the process
separated by a distance <i>r</i>, while <i>M,M'</i> are
independent realisations of the marginal distribution of marks.
</p>
<p>
Here <i>f</i> is any function
<i>f(m1,m2)</i>
with two arguments which are possible marks of the pattern,
and which returns a nonnegative real value.
Common choices of <i>f</i> are:
for continuous real-valued marks,
</p><p align="center"><i>f(m1,m2)= m1 * m2</i></p><p>
for discrete marks (multitype point patterns),
</p><p align="center"><i>f(m1,m2)= (m1 == m2)</i></p><p>
and for marks taking values in <i>[0,2 * pi)</i>,
</p><p align="center"><i>f(m1,m2) = sin(m1-m2)</i></p><p>.
</p>
<p>
Note that <i>rho_f(r)</i> is not a ``correlation''
in the usual statistical sense. It can take any 
nonnegative real value. The value 1 suggests ``lack of correlation'':
if the marks attached to the points of <code>X</code> are independent
and identically distributed, then
<i>rho_f(r) =  1</i>.
The interpretation of values larger or smaller than 1 depends
on the choice of function <i>f</i>.
</p>
<p>
The argument <code>X</code> must be a point pattern (object of class
<code>"ppp"</code>) or any data that are acceptable to <code><a href="as.ppp.html">as.ppp</a></code>.
It must be a marked point pattern.
</p>
<p>
The argument <code>f</code> determines the function to be applied to
pairs of marks. It has a sensible default, which depends on the
kind of marks in <code>X</code>. If the marks
are numeric values, then <code>f &lt;- function(m1, m2) { m1 * m2}</code>
computes the product of two marks.
If the marks are a factor (i.e. if <code>X</code> is a multitype point
pattern) then <code>f &lt;- function(m1, m2) { m1 == m2}</code> yields
the value 1 when the two marks are equal, and 0 when they are unequal.
These are the conventional definitions for numerical
marks and multitype points respectively.
</p>
<p>
Alternatively the argument <code>f</code> may be specified by the user.
It must be a function, accepting two arguments <code>m1</code>
and <code>m2</code> which are vectors of equal length containing mark
values (of the same type as the marks of <code>X</code>).
It must return a vector of numeric
values of the same length as <code>m1</code> and <code>m2</code>.
The values must be non-negative, and <code>NA</code> values are not permitted.
</p>
<p>
The argument <code>r</code> is the vector of values for the
distance <i>r</i> at which <i>rho_f(r)</i> is estimated.
</p>
<p>
This algorithm assumes that <code>X</code> can be treated
as a realisation of a stationary (spatially homogeneous) 
random spatial point process in the plane, observed through
a bounded window.
The window (which is specified in <code>X</code> as <code>X$window</code>)
may have arbitrary shape.
</p>
<p>
Biases due to edge effects are
treated in the same manner as in <code><a href="Kest.html">Kest</a></code>.
The edge corrections implemented here are
<dl>
<dt>isotropic/Ripley</dt><dd>Ripley's isotropic correction
(see Ripley, 1988; Ohser, 1983).
This is implemented only for rectangular and polygonal windows
(not for binary masks).
</dd>
<dt>translate</dt><dd>Translation correction (Ohser, 1983).
Implemented for all window geometries, but slow for
complex windows. 
</dd>
</dl>
<p>
Note that the estimator assumes the process is stationary (spatially
homogeneous). 
</p>
<p>
The numerator and denominator of the mark correlation function
(in the expression above) are estimated using density estimation
techniques. The user can choose between
<dl>
<dt><code>"density"</code></dt><dd>which uses the standard kernel
density estimation routine <code><a href="../../stats/html/density.html">density</a></code>, and
works only for evenly-spaced <code>r</code> values;
</dd>
<dt><code>"loess"</code></dt><dd>which uses the function <code>loess</code> in the
package <STRONG>modreg</STRONG>;
</dd>
<dt><code>"sm"</code></dt><dd>which uses the function <code>sm.density</code> in the
package <STRONG>sm</STRONG> and is extremely slow;
</dd>
<dt><code>"smrep"</code></dt><dd>which uses the function <code>sm.density</code> in the
package <STRONG>sm</STRONG> and is relatively fast, but may require manual
control of the smoothing parameter <code>hmult</code>.
</dd>
</dl>

<h3>Value</h3>

<p>
An object of class <code>"fv"</code> (see <code><a href="fv.object.html">fv.object</a></code>).
<br>
Essentially a data frame containing numeric columns 
</p>
<table summary="R argblock">
<tr valign="top"><td><code>r</code></td>
<td>
the values of the argument <i>r</i> 
at which the mark correlation function <i>rho_f(r)</i>
has been  estimated
</td></tr>
<tr valign="top"><td><code>theo</code></td>
<td>
the theoretical value of <i>rho_f(r)</i>
when the marks attached to different points are independent,
namely 1
</td></tr>
</table>
<p>

together with a column or columns named 
<code>"iso"</code> and/or <code>"trans"</code>,
according to the selected edge corrections. These columns contain
estimates of the function <i>rho_f(r)</i>
obtained by the edge corrections named.</p>

<h3>Author(s)</h3>

<p>
Adrian Baddeley
<a href="mailto:adrian@maths.uwa.edu.au">adrian@maths.uwa.edu.au</a>
<a href="http://www.maths.uwa.edu.au/~adrian/">http://www.maths.uwa.edu.au/~adrian/</a>
and Rolf Turner
<a href="mailto:rolf@math.unb.ca">rolf@math.unb.ca</a>
<a href="http://www.math.unb.ca/~rolf">http://www.math.unb.ca/~rolf</a>
</p>


<h3>References</h3>

<p>
Stoyan, D. and Stoyan, H. (1994)
Fractals, random shapes and point fields:
methods of geometrical statistics.
John Wiley and Sons.
</p>


<h3>See Also</h3>

<p>
<code><a href="Kest.html">Kest</a></code>,
<code><a href="Kmulti.html">Kmulti</a></code>
</p>


<h3>Examples</h3>

<pre>
    # CONTINUOUS-VALUED MARKS:
    # (1) Longleaf Pine data
    # marks represent tree diameter
    data(longleaf)
    # Subset of this large pattern
    swcorner &lt;- owin(c(0,100),c(0,100))
    sub &lt;- longleaf[ , swcorner]
    # mark correlation function
    mc &lt;- markcorr(sub)
    plot(mc)

    # (2) simulated data with independent marks
    X &lt;- rpoispp(100)
    X &lt;- X %mark% runif(X$n)
    Xc &lt;- markcorr(X)
    plot(Xc)
    
    # MULTITYPE DATA:
    # Hughes' amacrine data
    # Cells marked as 'on'/'off'
    data(amacrine)
    # (3) Kernel density estimate with Epanecnikov kernel
    # (as proposed by Stoyan &amp; Stoyan)
    M &lt;- markcorr(amacrine, function(m1,m2) {m1==m2},
                  correction="translate", method="density",
                  kernel="epanechnikov")
    plot(M)
    # Note: kernel="epanechnikov" comes from help(density)

    # (4) Same again with explicit control over bandwidth
    M &lt;- markcorr(amacrine, 
                  correction="translate", method="density",
                  kernel="epanechnikov", bw=0.02)
    # see help(density) for correct interpretation of 'bw'

   
</pre>



<hr><div align="center">[Package <em>spatstat</em> version 1.10-3 <a href="00Index.html">Index]</a></div>

</body></html>
