<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>R: Simulation envelopes of summary function</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../R.css">
</head><body>

<table width="100%" summary="page for envelope {spatstat}"><tr><td>envelope {spatstat}</td><td align="right">R Documentation</td></tr></table>
<h2>Simulation envelopes of summary function</h2>


<h3>Description</h3>

<p>
Computes simulation envelopes of a summary function.
</p>


<h3>Usage</h3>

<pre>
  envelope(Y, fun=Kest, nsim=99, nrank=1, verbose=TRUE, ...,
  simulate=NULL, clipdata=TRUE, start=NULL,control=list(nrep=1e5,expand=1.5),
  transform=NULL,global=FALSE,ginterval=NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>Y</code></td>
<td>
Either a point pattern (object of class
<code>"ppp"</code>) or a fitted point process model
(object of class <code>"ppm"</code>).
</td></tr>
<tr valign="top"><td><code>fun</code></td>
<td>
Function that computes the desired summary statistic
for a point pattern. 
</td></tr>
<tr valign="top"><td><code>nsim</code></td>
<td>
Number of simulated point patterns to be generated
when computing the envelopes.
</td></tr>
<tr valign="top"><td><code>nrank</code></td>
<td>
Integer. Rank of the envelope value amongst the <code>nsim</code> simulated
values. A rank of 1 means that the minimum and maximum
simulated values will be used.
</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>
Logical flag indicating whether to print progress reports
during the simulations.
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
Extra arguments passed to <code>fun</code>.
</td></tr>
<tr valign="top"><td><code>simulate</code></td>
<td>
Optional. An expression. If this is present, then the simulated
point patterns will be generated by evaluating this expression
<code>nsim</code> times.
</td></tr>
<tr valign="top"><td><code>clipdata</code></td>
<td>
Logical flag indicating whether the data point pattern should be
clipped to the same window as the simulated patterns,
before the summary function for the data is computed.
This should usually be <code>TRUE</code> to ensure that the
data and simulations are properly comparable.
</td></tr>
<tr valign="top"><td><code>start,control</code></td>
<td>
Optional. These specify the arguments <code>start</code> and <code>control</code>
of <code>rmh</code>, giving complete control over the
simulation algorithm.
</td></tr>
<tr valign="top"><td><code>transform</code></td>
<td>
Optional. A transformation to be applied to the
function values, before the envelopes are computed.
An expression object (see Details).
</td></tr>
<tr valign="top"><td><code>global</code></td>
<td>
Logical flag indicating whether envelopes should be pointwise
(<code>global=FALSE</code>) or simultaneous (<code>global=TRUE</code>).
</td></tr>
<tr valign="top"><td><code>ginterval</code></td>
<td>
Optional.
A vector of length 2 specifying
the interval of <i>r</i> values for the simultaneous critical
envelopes. Only relevant if <code>global=TRUE</code>.
</td></tr>
</table>

<h3>Details</h3>

<p>
Simulation envelopes can be used to assess the goodness-of-fit of
a point process model to point pattern data. See the References.
</p>
<p>
This function first generates <code>nsim</code> random point patterns
in one of the following ways. 
<ul>
<li>If <code>Y</code> is a point pattern (an object of class <code>"ppp"</code>)
and <code>simulate=NULL</code>,
then this routine generates <code>nsim</code> simulations of
Complete Spatial Randomness (i.e. <code>nsim</code> simulated point patterns
each being a realisation of the uniform Poisson point process)
with the same intensity as the pattern <code>Y</code>.
(If <code>Y</code> is a multitype point pattern, then the simulated patterns
are also given independent random marks; the probability
distribution of the random marks is determined by the
relative frequencies of marks in <code>Y</code>.) 
<li>If <code>Y</code> is a fitted point process model (an object of class
<code>"ppm"</code>) and <code>simulate=NULL</code>,
then this routine generates <code>nsim</code> simulated
realisations of that model.
<li>If <code>simulate</code> is supplied, then it must be
an expression. It will be evaluated <code>nsim</code> times to
yield <code>nsim</code> point patterns.
</ul>

<p>
The summary statistic <code>fun</code> is applied to each of these simulated
patterns. Typically <code>fun</code> is one of the functions
<code>Kest</code>, <code>Gest</code>, <code>Fest</code>, <code>Jest</code>, <code>pcf</code>,
<code>Kcross</code>, <code>Kdot</code>, <code>Gcross</code>, <code>Gdot</code>,
<code>Jcross</code>, <code>Jdot</code>, <code>Kmulti</code>, <code>Gmulti</code>,
<code>Jmulti</code> or <code>Kinhom</code>. It may also be a character string
containing the name of one of these functions.
</p>
<p>
The statistic <code>fun</code> can also be a user-supplied function;
if so, then it must have arguments <code>X</code> and <code>r</code>
like those in the functions listed above, and it must return an object
of class <code>"fv"</code>.
</p>
<p>
Upper and lower critical envelopes are computed in one of the following ways:
<dl>
<dt>pointwise:</dt><dd>by default, envelopes are calculated pointwise
(i.e. for each value of the distance argument <i>r</i>), by sorting the
<code>nsim</code> simulated values, and taking the <code>m</code>-th lowest
and <code>m</code>-th highest values, where <code>m = nrank</code>.
For example if <code>nrank=1</code>, the upper and lower envelopes
are the pointwise maximum and minimum of the simulated values.
</p>
<p>
The pointwise envelopes are <B>not</B> &ldquo;confidence bands&rdquo;
for the true value of the function! Rather,
they specify the critical points for a Monte Carlo test
(Ripley, 1981). The test is constructed by choosing a
<EM>fixed</EM> value of <i>r</i>, and rejecting the null hypothesis if the
observed function value
lies outside the envelope <EM>at this value of</EM> <i>r</i>.
This test has exact significance level
<code>alpha = 2 * nrank/(1 + nsim)</code>.
</dd>
<dt>simultaneous:</dt><dd>if <code>global=TRUE</code>, then the envelopes are
determined as follows. First we calculate the theoretical mean value of
the summary statistic (if we are testing CSR, the theoretical
value is supplied by <code>fun</code>; otherwise we compute the
average of all the simulated values and take this as an estimate
of the theoretical mean value). Then, for each simulation,
we compare the simulated curve to the theoretical curve, and compute the
maximum absolute difference between them (over the interval
of <i>r</i> values specified by <code>ginterval</code>). This gives a
deviation value <i>d[i]</i> for each of the <code>nsim</code>
simulations. Finally we take the <code>m</code>-th largest of the
deviation values, where <code>m=nrank</code>, and call this
<code>dcrit</code>. Then the simultaneous envelopes are of the form
<code>lo = theo - dcrit</code> and <code>hi = theo + dcrit</code> where
<code>theo</code> is the theoretical mean value. Simultaneous critical
envelopes have constant width <code>2 * dcrit</code>.
</p>
<p>
The simultaneous critical envelopes allow us to perform a different
Monte Carlo test (Ripley, 1981). The test rejects the null
hypothesis if the graph of the observed function
lies outside the envelope <B>at any value of</B> <i>r</i>.
This test has exact significance level
<code>alpha = nrank/(1 + nsim)</code>.
</dd>
</dl>

<p>
The return value is an object of class <code>"fv"</code> containing
the summary function for the data point pattern
and the upper and lower simulation envelopes. It can be plotted
using <code>plot.fv</code>.
</p>
<p>
Arguments can be passed to the function <code>fun</code> through
<code>...</code>. This makes it possible to select the edge correction
used to calculate the summary statistic. See the Examples.
Selecting only a single edge
correction will make the code run much faster.
</p>
<p>
If <code>Y</code> is a fitted point process model, and <code>simulate=NULL</code>,
then the model is simulated
by running the Metropolis-Hastings algorithm <code><a href="rmh.html">rmh</a></code>.
Complete control over this algorithm is provided by the 
arguments <code>start</code> and <code>control</code> which are passed
to <code><a href="rmh.html">rmh</a></code>.
</p>
<p>
For simultaneous critical envelopes (<code>global=TRUE</code>)
the following options are also useful:
<dl>
<dt><code>ginterval</code></dt><dd>determines the interval of <i>r</i> values
over which the deviation between curves is calculated.
It should be a numeric vector of length 2.
There is a sensible default (namely, the recommended plotting
interval for <code>fun(X)</code>).
</dd>
<dt><code>transform</code></dt><dd>specifies a transformation of the
summary function <code>fun</code> that will be carried out before the
deviations are computed. It must be an expression object
using the symbol <code>.</code> to represent the function value.
For example, 
the conventional way to normalise the <i>K</i> function
(Ripley, 1981) is to transform it to the <i>L</i> function
<i>L(r) = sqrt(K(r)/pi)</i>
and this is implemented by setting
<code>transform=expression(sqrt(./pi))</code>.
Such transforms are only useful if <code>global=TRUE</code>.
</dd>
</dl>

<h3>Value</h3>

<p>
An object of class <code>"fv"</code>, see <code><a href="fv.object.html">fv.object</a></code>,
which can be plotted directly using <code><a href="plot.fv.html">plot.fv</a></code>.
<br>
Essentially a data frame containing columns
</p>
<table summary="R argblock">
<tr valign="top"><td><code>r</code></td>
<td>
the vector of values of the argument <i>r</i> 
at which the summary function <code>fun</code> has been  estimated
</td></tr>
<tr valign="top"><td><code>obs</code></td>
<td>
values of the summary function for the data point pattern
</td></tr>
<tr valign="top"><td><code>lo</code></td>
<td>
lower envelope of simulations
</td></tr>
<tr valign="top"><td><code>hi</code></td>
<td>
upper envelope of simulations
</td></tr>
</table>

<h3>Author(s)</h3>

<p>
Adrian Baddeley
<a href="mailto:adrian@maths.uwa.edu.au">adrian@maths.uwa.edu.au</a>
<a href="http://www.maths.uwa.edu.au/~adrian/">http://www.maths.uwa.edu.au/~adrian/</a>
and Rolf Turner
<a href="mailto:rolf@math.unb.ca">rolf@math.unb.ca</a>
<a href="http://www.math.unb.ca/~rolf">http://www.math.unb.ca/~rolf</a>
</p>


<h3>References</h3>

<p>
Cressie, N.A.C. <EM>Statistics for spatial data</EM>.
John Wiley and Sons, 1991.
</p>
<p>
Diggle, P.J. <EM>Statistical analysis of spatial point patterns</EM>.
Arnold, 2003.
</p>
<p>
Ripley, B.D. (1981) 
<EM>Spatial statistics</EM>.
John Wiley and Sons.
</p>
<p>
Ripley, B.D. <EM>Statistical inference for spatial processes</EM>.
Cambridge University Press, 1988.
</p>
<p>
Stoyan, D. and Stoyan, H. (1994)
Fractals, random shapes and point fields:
methods of geometrical statistics.
John Wiley and Sons.
</p>


<h3>See Also</h3>

<p>
<code><a href="fv.object.html">fv.object</a></code>,
<code><a href="plot.fv.html">plot.fv</a></code>,
<code><a href="Kest.html">Kest</a></code>,
<code><a href="Gest.html">Gest</a></code>,
<code><a href="Fest.html">Fest</a></code>,
<code><a href="Jest.html">Jest</a></code>,
<code><a href="pcf.html">pcf</a></code>,
<code><a href="ppp.html">ppp</a></code>,
<code><a href="ppm.html">ppm</a></code>
</p>


<h3>Examples</h3>

<pre>
 data(simdat)
 X &lt;- simdat

 # Envelope of K function under CSR
 ## Not run: 
 plot(envelope(X))
 
## End(Not run)
 

 # Translation edge correction (this is also FASTER):
 ## Not run: 
 plot(envelope(X, correction="translate"))
 
## End(Not run)
 

 # Envelope of K function for simulations from model 
 data(cells)
 fit &lt;- ppm(cells, ~1, Strauss(0.05))
 ## Not run: 
 plot(envelope(fit))
 
## End(Not run)
 

 # Envelope of G function under CSR
 ## Not run: 
 plot(envelope(X, Gest))
 
## End(Not run)
 

 # Envelope of L function under CSR
 #  L(r) = sqrt(K(r)/pi)
 ## Not run: 
  E &lt;- envelope(X, Kest)
  plot(E, sqrt(./pi) ~ r)
 
## End(Not run)
 

 # Simultaneous critical envelope for L function
 ## Not run: 
  plot(envelope(X, Kest, transform=expression(sqrt(./pi)), global=TRUE))
 
## End(Not run)
 

 # How to pass arguments needed to compute the summary functions:
 # We want envelopes for Jcross(X, "A", "B") 
 # where "A" and "B" are types of points in the dataset 'demopat'

 data(demopat)
 ## Not run: 
 plot(envelope(demopat, Jcross, i="A", j="B"))
 
## End(Not run)
 
 
 # Use of `simulate'
 ## Not run: 
 plot(envelope(cells, Gest, simulate=expression(runifpoint(42))))
 plot(envelope(cells, Gest, simulate=expression(rMaternI(100,0.02))))
 
## End(Not run)
 

 # Envelope under random toroidal shifts
 data(amacrine)
 ## Not run: 
 plot(envelope(amacrine, Kcross, i="on", j="off",
               simulate=expression(rshift(amacrine, radius=0.25)))) 
 
## End(Not run)

 # Envelope under random shifts with erosion
 ## Not run: 
 plot(envelope(amacrine, Kcross, i="on", j="off",
              simulate=expression(rshift(amacrine, radius=0.1, edge="erode"))))
 
## End(Not run)
  
 # Envelope of INHOMOGENEOUS K-function with fitted trend
## Not run: 
 trend &lt;- density.ppp(X, 1.5)
 plot(envelope(X, Kinhom, lambda=trend,
         simulate=expression(rpoispp(trend))))
 
## End(Not run)
  
</pre>



<hr><div align="center">[Package <em>spatstat</em> version 1.10-3 <a href="00Index.html">Index]</a></div>

</body></html>
