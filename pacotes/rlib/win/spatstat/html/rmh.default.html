<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>R: Simulate Point Process Models using the Metropolis-Hastings Algorithm.</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../R.css">
</head><body>

<table width="100%" summary="page for rmh.default {spatstat}"><tr><td>rmh.default {spatstat}</td><td align="right">R Documentation</td></tr></table>
<h2>Simulate Point Process Models using the Metropolis-Hastings Algorithm.</h2>


<h3>Description</h3>

<p>
Generates a random point pattern, simulated from
a chosen point process model, using the Metropolis-Hastings
algorithm.
</p>


<h3>Usage</h3>

<pre>## Default S3 method:
rmh(model, start, control, verbose=TRUE, ...) </pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>model</code></td>
<td>
Data specifying the point process model
that is to be simulated.
</td></tr>
<tr valign="top"><td><code>start</code></td>
<td>
Data determining the initial state of
the algorithm.
</td></tr>
<tr valign="top"><td><code>control</code></td>
<td>
Data controlling the iterative behaviour
and termination of the algorithm.
</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>
Logical flag indicating whether to print progress
reports.
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
Further arguments which will be passed to
any trend functions in <code>model</code>.
</td></tr>
</table>

<h3>Details</h3>

<p>
This function generates simulated realisations from any of a range of
spatial point processes, using the Metropolis-Hastings algorithm.
It is the default method for the generic function <code><a href="rmh.html">rmh</a></code>.
</p>
<p>
This function executes a Metropolis-Hastings algorithm
with birth, death and shift proposals as described in
Geyer and Moller (1994).
</p>
<p>
The argument <code>model</code> specifies the point process model to be
simulated. It is either a list, or an object of class
<code>"rmhmodel"</code>, with the following components:
</p>

<dl>
<dt>cif</dt><dd>A character string specifying the choice of
interpoint interaction for the point process.
</dd>
<dt>par</dt><dd>Parameter values for the conditional
intensity function.
</dd>
<dt>w</dt><dd>(Optional) window in which the pattern is
to be generated. An object of class <code>"owin"</code>,
or data acceptable to <code><a href="as.owin.html">as.owin</a></code>.
</dd>
<dt>trend</dt><dd>Data specifying the spatial trend in the model, if it has a trend.
This may be a function, a pixel image (of class <code>"im"</code>),
(or a list of functions or images if the model
is multitype).
</p>
<p>
If the trend is a function or functions,
any auxiliary arguments <code>...</code> to <code>rmh.default</code>
will be passed to these functions, which
should be of the form <code>function(x, y, ...)</code>.
</dd>
<dt>types</dt><dd>List of possible types, for a multitype point process.
</dd>
</dl>
<p>
For full details of these parameters, see <code><a href="rmhmodel.html">rmhmodel</a></code>.
</p>
<p>
The argument <code>start</code> determines the initial state of the
Metropolis-Hastings algorithm. It is either a list, or an object
of class <code>"rmhstart"</code>, with the following components:
</p>

<dl>
<dt>n.start</dt><dd>Number of points in the initial point pattern.
A single integer, or a vector of integers giving the
numbers of points of each type in a multitype point pattern.
Incompatible with <code>x.start</code>.
</dd>
<dt>x.start</dt><dd>Initial point pattern configuration.
Incompatible with <code>n.start</code>.
</p>
<p>
<code>x.start</code> may be a point pattern (an
object of class <code>"ppp"</code>), or data which can be coerced
to this class by <code><a href="as.ppp.html">as.ppp</a></code>,  or an object with
components <code>x</code> and <code>y</code>, or a two-column matrix.
In the last two cases, the window for the pattern is determined
by <code>model$w</code>.
In the first two cases, if <code>model$w</code> is also present,
then the final simulated pattern will be clipped to
the window <code>model$w</code>.
</dd>
<dt>iseed</dt><dd>(Optional) seed for random number generator.
A triple of integers. Should not be specified
in normal usage!
</dd>
</dl>
<p>
For full details of these parameters, see <code><a href="rmhstart.html">rmhstart</a></code>.
</p>
<p>
The third argument <code>control</code> controls the simulation
procedure, iterative behaviour, and termination of the
Metropolis-Hastings algorithm. It is either a list, or an
object of class <code>"rmhcontrol"</code>, with components:
<dl>
<dt>p</dt><dd>The probability of proposing a ``shift''
(as opposed to a birth or death) in the Metropolis-Hastings
algorithm.
</dd>
<dt>q</dt><dd>The conditional probability of proposing a death
(rather than a birth)
given that birth/death has been chosen over shift.  
</dd>
<dt>nrep</dt><dd>The number of repetitions or iterations
to be made by the Metropolis-Hastings algorithm.  It should
be large.
</dd>
<dt>expand</dt><dd>Either a numerical expansion factor, or
a window (object of class <code>"owin"</code>). Indicates that
the process is to be simulated on a larger domain than the
original data window <code>w</code>, then clipped to <code>w</code>
when the algorithm has finished.
</p>
<p>
If the model has a trend, then in order for expansion to
be feasible, the trend must be given either as a function,
or an image whose bounding box is large enough to contain
the expanded window.
</dd>
<dt>periodic</dt><dd>A logical scalar; if <code>periodic</code> is <code>TRUE</code>
we simulate a process on the torus formed by identifying
opposite edges of a rectangular window.  
</dd>
<dt>ptypes</dt><dd>A vector of probabilities (summing to 1) to be used
in assigning a random type to a new point.
</dd>
<dt>fixall</dt><dd>A logical scalar specifying whether to condition on
the number of points of each type.
</dd>
<dt>nverb</dt><dd>An integer specifying how often ``progress reports''
(which consist simply of the number of repetitions completed)
should be printed out.  If nverb is left at 0, the default,
the simulation proceeds silently.
</dd>
</dl>
<p>
For full details of these parameters, see <code><a href="rmhcontrol.html">rmhcontrol</a></code>.
</p>
<p>
It is possible to simulate the model conditionally upon the number of
points, or in the case of multitype processes, upon the number of
points of each type.  To condition upon the total number of points,
set <code>control$p</code> (the probability of a shift) equal to 1.
The number of points is then determined by the starting state, which
may be specified either by setting <code>start$n.start</code> to be a
scalar, or by setting the initial pattern <code>start$x.start</code>.
</p>
<p>
To condition upon the
number of points of each type, set <code>control$p</code> equal to 1
and <code>control$fixall</code> to be <code>TRUE</code>.
The number of points is then determined by the starting state, which
may be specified either by setting <code>start$n.start</code> to be an
integer vector, or by setting the initial pattern <code>start$x.start</code>.
</p>
<p>
When we simulate conditionally, no expansion of the window is possible.
</p>


<h3>Value</h3>

<p>
A point pattern (an object of class <code>"ppp"</code>, see
<code><a href="ppp.object.html">ppp.object</a></code>).
<br>
The returned value has an attribute <code>info</code> containing
modified versions of the arguments
<code>model</code>, <code>start</code>, and <code>control</code> which together specify
the exact simulation procedure.</p>

<h3>Warnings</h3>

<p>
There is never a guarantee that the Metropolis-Hastings algorithm
has converged to its limiting distribution.
</p>
<p>
If <code>start$x.start</code> is specified then <code>expand</code> is set equal to 1
and simulation takes place in <code>x.start$window</code>.  Any specified
value for <code>expand</code> is simply ignored.
</p>
<p>
The presence of both a component <code>w</code> of <code>model</code> and a
non-null value for <code>x.start$window</code> makes sense ONLY if <code>w</code>
is contained in <code>x.start$window</code>.  
</p>
<p>
For multitype processes make sure that, even if there is to be no
trend corresponding to a particular type, there is still a component
(a NULL component) for that type, in the list.
</p>


<h3>Extensions</h3>

<p>
The argument <code>model$cif</code> matches the name of a Fortran
subroutine which calculates the conditional intensity function
for the model.  It is intended that more options will be
added in the future.  The very brave user <B>could</B> try
to add her own.  Note that in addition to writing Fortran
code for the new conditional intensity function, the user
would have to modify the code in the files <code>cif.f</code> and
<code>rmh.default.R</code> appropriately.  (And of course re-install
the <STRONG>spatstat</STRONG> package so as to update the dynamically
loadable shared object <code>spatstat.so</code>.)
</p>
<p>
Note that the <code>lookup</code> conditional intensity function
permits the simulation (in theory, to any desired degree
of approximation) of any pairwise interaction process for
which the interaction depends only on the distance between
the pair of points.
</p>


<h3>Author(s)</h3>

<p>
Adrian Baddeley
<a href="mailto:adrian@maths.uwa.edu.au">adrian@maths.uwa.edu.au</a>
<a href="http://www.maths.uwa.edu.au/~adrian/">http://www.maths.uwa.edu.au/~adrian/</a>
and Rolf Turner
<a href="mailto:rolf@math.unb.ca">rolf@math.unb.ca</a>
<a href="http://www.math.unb.ca/~rolf">http://www.math.unb.ca/~rolf</a>
</p>


<h3>References</h3>

<p>
Baddeley, A. and Turner, R. (2000) Practical maximum
pseudolikelihood for spatial point patterns.
<EM>Australian and New Zealand Journal of Statistics</EM>
<B>42</B>, 283 &ndash; 322.
</p>
<p>
Diggle, P. J. (2003) <EM>Statistical Analysis of Spatial Point
Patterns</EM> (2nd ed.) Arnold, London.
</p>
<p>
Diggle, P.J. and Gratton, R.J. (1984)
Monte Carlo methods of inference for implicit statistical models.
<EM>Journal of the Royal Statistical Society, series B</EM>
<B>46</B>, 193 &ndash; 212.
</p>
<p>
Diggle, P.J., Gates, D.J., and Stibbard, A. (1987)
A nonparametric estimator for pairwise-interaction point processes.
Biometrika <B>74</B>, 763 &ndash; 770.
</p>
<p>
Geyer, C.J. and M{o}ller, J. (1994)
Simulation procedures and likelihood inference for spatial
point processes.
<EM>Scandinavian Journal of Statistics</EM> <B>21</B>, 359&ndash;373.
</p>
<p>
Geyer, C.J. (1999)
Likelihood Inference for Spatial Point
Processes. Chapter 3 in  O.E. Barndorff-Nielsen, W.S. Kendall and
M.N.M. Van Lieshout (eds) <EM>Stochastic Geometry: Likelihood and
Computation</EM>, Chapman and Hall / CRC,  Monographs on Statistics and
Applied Probability, number 80. Pages 79&ndash;140.
</p>


<h3>See Also</h3>

<p>
<code><a href="rmh.html">rmh</a></code>,
<code><a href="rmh.ppm.html">rmh.ppm</a></code>,
<code><a href="rStrauss.html">rStrauss</a></code>,
<code><a href="ppp.html">ppp</a></code>,
<code><a href="ppm.html">ppm</a></code>,
<code><a href="Strauss.html">Strauss</a></code>,
<code><a href="Softcore.html">Softcore</a></code>,
<code><a href="StraussHard.html">StraussHard</a></code>,
<code><a href="MultiStrauss.html">MultiStrauss</a></code>,
<code><a href="MultiStraussHard.html">MultiStraussHard</a></code>,
<code><a href="DiggleGratton.html">DiggleGratton</a></code>
</p>


<h3>Examples</h3>

<pre>
   ## Not run: 
   nr   &lt;- 1e5
   nv  &lt;- 5000
   
## End(Not run)
   
   set.seed(961018)
   
   # Strauss process.
   mod01 &lt;- list(cif="strauss",par=c(beta=2,gamma=0.2,r=0.7),
                 w=c(0,10,0,10))
   X1.strauss &lt;- rmh(model=mod01,start=list(n.start=80),
                     control=list(nrep=nr,nverb=nv))
   
   # Strauss process, conditioning on n = 80:
   X2.strauss &lt;- rmh(model=mod01,start=list(n.start=80),
                     control=list(p=1,nrep=nr,nverb=nv))
   
   # Strauss process equal to pure hardcore:
   mod02 &lt;- list(cif="strauss",par=c(beta=2,gamma=0,r=0.7),w=c(0,10,0,10))
   X3.strauss &lt;- rmh(model=mod02,start=list(n.start=60,iseed=c(42,17,69)),
                     control=list(nrep=nr,nverb=nv))
   
   # Strauss process in a polygonal window.
   x     &lt;- c(0.55,0.68,0.75,0.58,0.39,0.37,0.19,0.26,0.42)
   y     &lt;- c(0.20,0.27,0.68,0.99,0.80,0.61,0.45,0.28,0.33)
   mod03 &lt;- list(cif="strauss",par=c(beta=2000,gamma=0.6,r=0.07),
                w=owin(poly=list(x=x,y=y)))
   X4.strauss &lt;- rmh(model=mod03,start=list(n.start=90),
                     control=list(nrep=nr,nverb=nv))
   
   # Strauss process in a polygonal window, conditioning on n = 80.
   X5.strauss &lt;- rmh(model=mod03,start=list(n.start=90),
                     control=list(p=1,nrep=nr,nverb=nv))
   
   # Strauss process, starting off from X4.strauss, but with the
   # polygonal window replace by a rectangular one.  At the end,
   # the generated pattern is clipped to the original polygonal window.
   xxx &lt;- X4.strauss
   xxx$window &lt;- as.owin(c(0,1,0,1))
   X6.strauss &lt;- rmh(model=mod03,start=list(x.start=xxx),
                     control=list(nrep=nr,nverb=nv))
   
   # Strauss with hardcore:
   mod04 &lt;- list(cif="straush",par=c(beta=2,gamma=0.2,r=0.7,hc=0.3),
                w=c(0,10,0,10))
   X1.straush &lt;- rmh(model=mod04,start=list(n.start=70),
                     control=list(nrep=nr,nverb=nv))
   
   # Another Strauss with hardcore (with a perhaps surprising result):
   mod05 &lt;- list(cif="straush",par=c(beta=80,gamma=0.36,r=45,hc=2.5),
                w=c(0,250,0,250))
   X2.straush &lt;- rmh(model=mod05,start=list(n.start=250),
                     control=list(nrep=nr,nverb=nv))
   
   # Pure hardcore (identical to X3.strauss).
   mod06 &lt;- list(cif="straush",par=c(beta=2,gamma=1,r=1,hc=0.7),
                w=c(0,10,0,10))
   X3.straush &lt;- rmh(model=mod06,start=list(n.start=60, iseed=c(42,17,69)),
                     control=list(nrep=nr,nverb=nv))
   
   # Soft core:
   par3 &lt;- c(0.8,0.1,0.5)
   w    &lt;- c(0,10,0,10)
   mod07 &lt;- list(cif="sftcr",par=c(beta=0.8,sigma=0.1,kappa=0.5),
                w=c(0,10,0,10))
   X.sftcr &lt;- rmh(model=mod07,start=list(n.start=70),
                  control=list(nrep=nr,nverb=nv))
   
   # Multitype Strauss:
   beta &lt;- c(0.027,0.008)
   gmma &lt;- matrix(c(0.43,0.98,0.98,0.36),2,2)
   r    &lt;- matrix(c(45,45,45,45),2,2)
   mod08 &lt;- list(cif="straussm",par=list(beta=beta,gamma=gmma,radii=r),
                w=c(0,250,0,250))
   X1.straussm &lt;- rmh(model=mod08,start=list(n.start=80),
                      control=list(ptypes=c(0.75,0.25),nrep=nr,nverb=nv))
   
   # Multitype Strauss conditioning upon the total number
   # of points being 80:
   X2.straussm &lt;- rmh(model=mod08,start=list(n.start=80),
                      control=list(p=1,ptypes=c(0.75,0.25),nrep=nr,
                                   nverb=nv))
   
   # Conditioning upon the number of points of type 1 being 60
   # and the number of points of type 2 being 20:
   X3.straussm &lt;- rmh(model=mod08,start=list(n.start=c(60,20)),
                      control=list(fixall=TRUE,p=1,ptypes=c(0.75,0.25),
                                   nrep=nr,nverb=nv))
   
   # Multitype Strauss hardcore:
   rhc  &lt;- matrix(c(9.1,5.0,5.0,2.5),2,2)
   mod09 &lt;- list(cif="straushm",par=list(beta=beta,gamma=gmma,
                iradii=r,hradii=rhc),w=c(0,250,0,250))
   X.straushm &lt;- rmh(model=mod09,start=list(n.start=80),
                     control=list(ptypes=c(0.75,0.25),nrep=nr,nverb=nv))
   
   # Multitype Strauss hardcore with trends for each type:
   beta  &lt;- c(0.27,0.08)
   tr3   &lt;- function(x,y){x &lt;- x/250; y &lt;- y/250;
                           exp((6*x + 5*y - 18*x^2 + 12*x*y - 9*y^2)/6)
                         }
                         # log quadratic trend
   tr4   &lt;- function(x,y){x &lt;- x/250; y &lt;- y/250;
                         exp(-0.6*x+0.5*y)}
                        # log linear trend
   mod10 &lt;- list(cif="straushm",par=list(beta=beta,gamma=gmma,
                 iradii=r,hradii=rhc),w=c(0,250,0,250),
                 trend=list(tr3,tr4))
   X1.straushm.trend &lt;- rmh(model=mod10,start=list(n.start=350),
                            control=list(ptypes=c(0.75,0.25),
                            nrep=nr,nverb=nv))
   
   # Multitype Strauss hardcore with trends for each type, given as images:
   bigwin &lt;- square(250)
   i1 &lt;- as.im(tr3, bigwin)
   i2 &lt;- as.im(tr4, bigwin)   
   mod11 &lt;- list(cif="straushm",par=list(beta=beta,gamma=gmma,
                 iradii=r,hradii=rhc),w=bigwin,
                 trend=list(i1,i2))
   X2.straushm.trend &lt;- rmh(model=mod11,start=list(n.start=350),
                            control=list(ptypes=c(0.75,0.25),expand=1,
                            nrep=nr,nverb=nv))
   
   # Diggle, Gates, and Stibbard:
   mod12 &lt;- list(cif="dgs",par=c(beta=3600,rho=0.08),w=c(0,1,0,1))
   X.dgs &lt;- rmh(model=mod12,start=list(n.start=300),
                control=list(nrep=nr,nverb=nv))
   
   # Diggle-Gratton:
   mod13 &lt;- list(cif="diggra",
                 par=c(beta=1800,kappa=3,delta=0.02,rho=0.04),
                 w=square(1))
   X.diggra &lt;- rmh(model=mod13,start=list(n.start=300),
                   control=list(nrep=nr,nverb=nv))
   
   # Geyer:
   mod14 &lt;- list(cif="geyer",par=c(beta=1.25,gamma=1.6,r=0.2,sat=4.5),
                 w=c(0,10,0,10))
   X1.geyer &lt;- rmh(model=mod14,start=list(n.start=200),
                   control=list(nrep=nr,nverb=nv))
   
   # Geyer; same as a Strauss process with parameters
   # (beta=2.25,gamma=0.16,r=0.7):
   
   mod15 &lt;- list(cif="geyer",par=c(beta=2.25,gamma=0.4,r=0.7,sat=10000),
                 w=c(0,10,0,10))
   X2.geyer &lt;- rmh(model=mod15,start=list(n.start=200),
                   control=list(nrep=nr,nverb=nv))
   
   mod16 &lt;- list(cif="geyer",par=c(beta=8.1,gamma=2.2,r=0.08,sat=3))
   data(redwood)
   X3.geyer &lt;- rmh(model=mod16,start=list(x.start=redwood),
                   control=list(periodic=TRUE,nrep=nr,nverb=nv))
   
   # Geyer, starting from the redwood data set, simulating
   # on a torus, and conditioning on n:
   X4.geyer &lt;- rmh(model=mod16,start=list(x.start=redwood),
                   control=list(p=1,periodic=TRUE,nrep=nr,nverb=nv))

   # Lookup (interaction function h_2 from page 76, Diggle (2003)):
      r &lt;- seq(from=0,to=0.2,length=101)[-1] # Drop 0.
      h &lt;- 20*(r-0.05)
      h[r&lt;0.05] &lt;- 0
      h[r&gt;0.10] &lt;- 1
      mod17 &lt;- list(cif="lookup",par=list(beta=4000,h=h,r=r),w=c(0,1,0,1))
      X.lookup &lt;- rmh(model=mod17,start=list(n.start=100),
                      control=list(nrep=nr,nverb=nv))
                   
   # Strauss with trend
   tr &lt;- function(x,y){x &lt;- x/250; y &lt;- y/250;
                           exp((6*x + 5*y - 18*x^2 + 12*x*y - 9*y^2)/6)
                         }
   beta &lt;- 0.3
   gmma &lt;- 0.5
   r    &lt;- 45
   mod17 &lt;- list(cif="strauss",par=c(beta=beta,gamma=gmma,r=r),w=c(0,250,0,250),
                 trend=tr3)
   X1.strauss.trend &lt;- rmh(model=mod17,start=list(n.start=90),
                           control=list(nrep=nr,nverb=nv))
</pre>



<hr><div align="center">[Package <em>spatstat</em> version 1.10-3 <a href="00Index.html">Index]</a></div>

</body></html>
