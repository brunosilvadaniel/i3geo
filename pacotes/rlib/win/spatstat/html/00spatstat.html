<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>R: The Spatstat Package</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../R.css">
</head><body>

<table width="100%" summary="page for spatstat {spatstat}"><tr><td>spatstat {spatstat}</td><td align="right">R Documentation</td></tr></table>
<h2>The Spatstat Package</h2>


<h3>Description</h3>

<p>
This is a summary of the features of 
<STRONG>spatstat</STRONG>, a package in <code>R</code>
for the statistical analysis of spatial point patterns.
</p>


<h3>Details</h3>

<p>
<STRONG>spatstat</STRONG> is a package for the statistical analysis
of spatial data. Currently, it deals mainly with the analysis of
patterns of points in the plane.  The points may carry `marks',
and the spatial region in which the points were recorded 
may have arbitrary shape. 
</p>
<p>
The package supports
<ul>
<li>creation, manipulation and plotting of point patterns
<li>exploratory data analysis 
<li>simulation of point process models
<li>parametric model-fitting
<li>hypothesis tests and diagnostics
</ul>
<p>
The point process models to be fitted
may be quite general Gibbs/Markov models; they may include spatial trend,
dependence on covariates, and interpoint interactions of any order (i.e.
not restricted to pairwise interactions). Models are specified by 
a <code>formula</code> in the <code>R</code> language, and are fitted using
a single function <code><a href="ppm.html">ppm</a></code> analogous to
<code><a href="../../VGAM/html/notdocumentedyet.html">lm</a></code> and <code><a href="../../VGAM/html/notdocumentedyet.html">glm</a></code>.
It is also possible to fit cluster process models by the method of
minimum contrast.
</p>


<h3>Getting Started</h3>

<p>
Type <code>demo(spatstat)</code> for an overall demonstration 
of the package.
</p>
<p>
An introduction to the package is available in the
file <code>Intro.pdf</code> in the <code>doc</code> directory supplied in the
installation of the package. 
</p>
<p>
The package is described more fully in the paper by
Baddeley and Turner (2005a), available online.
</p>


<h3>FUNCTIONS AND DATASETS</h3>

<p>
Following is a summary of the main functions and datasets
in the <STRONG>spatstat</STRONG> package.
Alternatively an alphabetical list of all functions and
datasets is available by typing <code>library(help=spatstat)</code>.
</p>
<p>
For further information on any of these,
type <code>help(name)</code> where <code>name</code> is the name of the function
or dataset.
</p>


<h3>CONTENTS:</h3>

<p>
<table summary="Rd table">
<tr>
  <td align="left">I. </td>  <td align="left"> Creating and manipulating data </td>
</tr>
<tr>
  <td align="left"> II. </td>  <td align="left"> Exploratory Data Analysis </td>
</tr>
<tr>
  <td align="left"> III. </td>  <td align="left"> Model fitting (cluster models) </td>
</tr>
<tr>
  <td align="left"> IV. </td>  <td align="left"> Model fitting (Gibbs models) </td>
</tr>
<tr>
  <td align="left"> V. </td>  <td align="left"> Tests and diagnostics</td>
</tr>
<tr>
  <td align="left"> VI. </td>  <td align="left"> Documentation </td>
</tr>
</table>


<h3>I. CREATING AND MANIPULATING DATA</h3>

<p>
<B>To create a point pattern:</B>
</p>

<table summary="Rd table">
<tr>
  <td align="left"><code><a href="ppp.html">ppp</a></code> </td>  <td align="left"> create a point pattern from <i>(x,y)</i> and window information </td>
</tr>
<tr>
  <td align="left"> </td>  <td align="left"> <code>ppp(x, y, xlim, ylim)</code> for rectangular window</td>
</tr>
<tr>
  <td align="left"> </td>  <td align="left"> <code>ppp(x, y, poly)</code> for polygonal window </td>
</tr>
<tr>
  <td align="left"> </td>  <td align="left"> <code>ppp(x, y, mask)</code> for binary image window </td>
</tr>
<tr>
  <td align="left"> <code><a href="as.ppp.html">as.ppp</a></code> </td>  <td align="left"> convert other types of data to a <code>ppp</code> object </td>
</tr>
<tr>
  <td align="left"> <code><a href="clickppp.html">clickppp</a></code> </td>  <td align="left"> interactively add points to a plot </td>
</tr>
<tr>
  <td align="left"> <code><a href="setmarks.html">setmarks</a></code>, <code>%mark%</code>  </td>  <td align="left"> attach/reassign marks to a point pattern </td>
</tr>
</table>

<p>
<B>To simulate a random point pattern:</B>
</p>

<table summary="Rd table">
<tr>
  <td align="left"><code><a href="runifpoint.html">runifpoint</a></code> </td>  <td align="left"> generate <i>n</i> independent uniform random points </td>
</tr>
<tr>
  <td align="left"> <code><a href="rpoint.html">rpoint</a></code> </td>  <td align="left"> generate <i>n</i> independent random points </td>
</tr>
<tr>
  <td align="left"> <code><a href="rmpoint.html">rmpoint</a></code> </td>  <td align="left"> generate <i>n</i> independent multitype random points </td>
</tr>
<tr>
  <td align="left"> <code><a href="rpoispp.html">rpoispp</a></code> </td>  <td align="left"> simulate the (in)homogeneous Poisson point process </td>
</tr>
<tr>
  <td align="left"> <code><a href="rmpoispp.html">rmpoispp</a></code> </td>  <td align="left"> simulate the (in)homogeneous multitype Poisson point process </td>
</tr>
<tr>
  <td align="left"> <code><a href="runifdisc.html">runifdisc</a></code> </td>  <td align="left"> generate <i>n</i> independent uniform random points in disc</td>
</tr>
<tr>
  <td align="left"> <code><a href="rstrat.html">rstrat</a></code> </td>  <td align="left"> stratified random sample of points </td>
</tr>
<tr>
  <td align="left"> <code><a href="rsyst.html">rsyst</a></code> </td>  <td align="left"> systematic random sample of points </td>
</tr>
<tr>
  <td align="left"> <code><a href="rMaternI.html">rMaternI</a></code>  </td>  <td align="left"> simulate the Mat'ern Model I inhibition process</td>
</tr>
<tr>
  <td align="left"> <code><a href="rMaternII.html">rMaternII</a></code> </td>  <td align="left"> simulate the Mat'ern Model II inhibition process</td>
</tr>
<tr>
  <td align="left"> <code><a href="rSSI.html">rSSI</a></code> </td>  <td align="left"> simulate Simple Sequential Inhibition process</td>
</tr>
<tr>
  <td align="left"> <code><a href="rStrauss.html">rStrauss</a></code> </td>  <td align="left"> simulate Strauss process (perfect simulation)</td>
</tr>
<tr>
  <td align="left"> <code><a href="rNeymanScott.html">rNeymanScott</a></code> </td>  <td align="left"> simulate a general Neyman-Scott process</td>
</tr>
<tr>
  <td align="left"> <code><a href="rMatClust.html">rMatClust</a></code> </td>  <td align="left"> simulate the Mat'ern Cluster process</td>
</tr>
<tr>
  <td align="left"> <code><a href="rThomas.html">rThomas</a></code> </td>  <td align="left"> simulate the Thomas process  </td>
</tr>
<tr>
  <td align="left"> <code><a href="rthin.html">rthin</a></code> </td>  <td align="left">  random thinning  </td>
</tr>
<tr>
  <td align="left"> <code><a href="rcell.html">rcell</a></code> </td>  <td align="left"> simulate the Baddeley-Silverman cell process  </td>
</tr>
<tr>
  <td align="left"> <code><a href="rmh.html">rmh</a></code> </td>  <td align="left"> simulate Gibbs point process using Metropolis-Hastings  </td>
</tr>
</table>

<p>
<B>To randomly change an existing point pattern:</B>
</p>

<table summary="Rd table">
<tr>
  <td align="left"><code><a href="rlabel.html">rlabel</a></code> </td>  <td align="left"> random (re)labelling of a multitype point pattern </td>
</tr>
<tr>
  <td align="left"> <code><a href="rshift.html">rshift</a></code> </td>  <td align="left"> random shift (including toroidal shifts) </td>
</tr>
</table>

<p>
<B>Standard point pattern datasets:</B>
</p>
<p>
Remember to say <code><a href="../../Zelig/html/immigration.html">data</a>(bramblecanes)</code> etc.
</p>

<table summary="Rd table">
<tr>
  <td align="left"><code><a href="amacrine.html">amacrine</a></code> </td>  <td align="left"> Austin Hughes' rabbit amacrine cells </td>
</tr>
<tr>
  <td align="left"> <code><a href="ants.html">ants</a></code> </td>  <td align="left"> Harkness-Isham ant nests data</td>
</tr>
<tr>
  <td align="left"> <code><a href="bei.html">bei</a></code> </td>  <td align="left"> Tropical rainforest trees </td>
</tr>
<tr>
  <td align="left"> <code><a href="betacells.html">betacells</a></code> </td>  <td align="left"> Waessle et al. cat retinal ganglia data </td>
</tr>
<tr>
  <td align="left"> <code><a href="bramblecanes.html">bramblecanes</a></code> </td>  <td align="left"> Bramble Canes data </td>
</tr>
<tr>
  <td align="left"> <code><a href="cells.html">cells</a></code> </td>  <td align="left"> Crick-Ripley biological cells data </td>
</tr>
<tr>
  <td align="left"> <code><a href="chorley.html">chorley</a></code> </td>  <td align="left"> Chorley-Ribble cancer data </td>
</tr>
<tr>
  <td align="left"> <code><a href="copper.html">copper</a></code> </td>  <td align="left"> Berman-Huntington copper deposits data </td>
</tr>
<tr>
  <td align="left"> <code><a href="demopat.html">demopat</a></code> </td>  <td align="left"> Synthetic point pattern </td>
</tr>
<tr>
  <td align="left"> <code><a href="finpines.html">finpines</a></code> </td>  <td align="left"> Finnish Pines data </td>
</tr>
<tr>
  <td align="left"> <code><a href="hamster.html">hamster</a></code> </td>  <td align="left"> Aherne's hamster tumour data </td>
</tr>
<tr>
  <td align="left"> <code><a href="humberside.html">humberside</a></code> </td>  <td align="left"> North Humberside childhood leukaemia data </td>
</tr>
<tr>
  <td align="left"> <code><a href="japanesepines.html">japanesepines</a></code> </td>  <td align="left"> Japanese Pines data </td>
</tr>
<tr>
  <td align="left"> <code><a href="lansing.html">lansing</a></code> </td>  <td align="left"> Lansing Woods data </td>
</tr>
<tr>
  <td align="left"> <code><a href="longleaf.html">longleaf</a></code> </td>  <td align="left"> Longleaf Pines data </td>
</tr>
<tr>
  <td align="left"> <code><a href="nztrees.html">nztrees</a></code> </td>  <td align="left"> Mark-Esler-Ripley trees data </td>
</tr>
<tr>
  <td align="left"> <code><a href="redwood.html">redwood</a></code> </td>  <td align="left"> Strauss-Ripley redwood saplings data </td>
</tr>
<tr>
  <td align="left"> <code><a href="redwoodfull.html">redwoodfull</a></code> </td>  <td align="left"> Strauss redwood saplings data (full set) </td>
</tr>
<tr>
  <td align="left"> <code><a href="residualspaper.html">residualspaper</a></code> </td>  <td align="left"> Data from Baddeley et al (2005) </td>
</tr>
<tr>
  <td align="left"> <code><a href="simdat.html">simdat</a></code> </td>  <td align="left"> Simulated point pattern (inhomogeneous, with interaction) </td>
</tr>
<tr>
  <td align="left"> <code><a href="spruces.html">spruces</a></code> </td>  <td align="left"> Spruce trees in Saxonia </td>
</tr>
<tr>
  <td align="left"> <code><a href="swedishpines.html">swedishpines</a></code> </td>  <td align="left"> Strand-Ripley swedish pines data </td>
</tr>
</table>

<p>
<B>To manipulate a point pattern:</B>
</p>

<table summary="Rd table">
<tr>
  <td align="left"><code><a href="plot.ppp.html">plot.ppp</a></code> </td>  <td align="left"> plot a point pattern (e.g. <code>plot(X)</code>) </td>
</tr>
<tr>
  <td align="left"> <code><a href="subset.ppp.html">subset.ppp</a></code>, <code>"[.ppp"</code> </td>  <td align="left"> extract or replace a subset of a point pattern </td>
</tr>
<tr>
  <td align="left"> </td>  <td align="left"> <code>pp[subset]</code> </td>
</tr>
<tr>
  <td align="left"> </td>  <td align="left">  <code>pp[, subwindow]</code> </td>
</tr>
<tr>
  <td align="left"> <code><a href="superimpose.html">superimpose</a></code> </td>  <td align="left"> superimpose any number of point patterns  </td>
</tr>
<tr>
  <td align="left"> <code><a href="cut.ppp.html">cut.ppp</a></code> </td>  <td align="left"> discretise the marks in a point pattern </td>
</tr>
<tr>
  <td align="left"> <code><a href="unmark.html">unmark</a></code> </td>  <td align="left"> remove marks  </td>
</tr>
<tr>
  <td align="left"> <code><a href="setmarks.html">setmarks</a></code> </td>  <td align="left"> attach marks or reset marks  </td>
</tr>
<tr>
  <td align="left"> <code><a href="split.ppp.html">split.ppp</a></code> </td>  <td align="left"> divide pattern into sub-patterns </td>
</tr>
<tr>
  <td align="left"> <code><a href="rotate.html">rotate</a></code> </td>  <td align="left"> rotate pattern  </td>
</tr>
<tr>
  <td align="left"> <code><a href="shift.html">shift</a> </code> </td>  <td align="left"> translate pattern  </td>
</tr>
<tr>
  <td align="left"> <code><a href="affine.html">affine</a></code> </td>  <td align="left"> apply affine transformation</td>
</tr>
<tr>
  <td align="left"> <code><a href="density.ppp.html">density.ppp</a></code> </td>  <td align="left"> kernel smoothing</td>
</tr>
<tr>
  <td align="left"> <code><a href="identify.ppp.html">identify.ppp</a></code> </td>  <td align="left"> interactively identify points </td>
</tr>
<tr>
  <td align="left"> <code><a href="unique.ppp.html">unique.ppp</a></code> </td>  <td align="left"> remove duplicate points </td>
</tr>
<tr>
  <td align="left"> <code><a href="duplicated.ppp.html">duplicated.ppp</a></code> </td>  <td align="left"> determine which points are duplicates </td>
</tr>
</table>
<p>
See <code><a href="spatstat.options.html">spatstat.options</a></code> to control plotting behaviour.
</p>
<p>
<B>To create a window:</B>
</p>
<p>
An object of class <code>"owin"</code> describes a spatial region
(a window of observation).
</p>

<table summary="Rd table">
<tr>
  <td align="left"><code><a href="owin.html">owin</a></code>      </td>  <td align="left">    Create a window object </td>
</tr>
<tr>
  <td align="left"> </td>  <td align="left"> <code>owin(xlim, ylim)</code> for rectangular window </td>
</tr>
<tr>
  <td align="left"> </td>  <td align="left"> <code>owin(poly)</code> for polygonal window </td>
</tr>
<tr>
  <td align="left"> </td>  <td align="left"> <code>owin(mask)</code> for binary image window </td>
</tr>
<tr>
  <td align="left"> <code><a href="as.owin.html">as.owin</a></code>   </td>  <td align="left"> Convert other data to a window object </td>
</tr>
<tr>
  <td align="left"> <code><a href="square.html">square</a></code>    </td>  <td align="left">    make a square window </td>
</tr>
<tr>
  <td align="left"> <code><a href="disc.html">disc</a></code>    </td>  <td align="left">      make a circular window </td>
</tr>
<tr>
  <td align="left"> <code><a href="ripras.html">ripras</a></code>    </td>  <td align="left"> Ripley-Rasson estimator of window, given only the points </td>
</tr>
<tr>
  <td align="left"> <code><a href="letterR.html">letterR</a></code>    </td>  <td align="left"> polygonal window in the shape of the {sf R} logo </td>
</tr>
</table>

<p>
<B>To manipulate a window:</B>
</p>

<table summary="Rd table">
<tr>
  <td align="left"><code><a href="plot.owin.html">plot.owin</a></code> </td>  <td align="left">    plot a window. </td>
</tr>
<tr>
  <td align="left"> </td>  <td align="left">            <code>plot(W)</code></td>
</tr>
<tr>
  <td align="left"> <code><a href="bounding.box.html">bounding.box</a></code> </td>  <td align="left"> Find a tight bounding box for the window </td>
</tr>
<tr>
  <td align="left"> <code><a href="erode.owin.html">erode.owin</a></code>        </td>  <td align="left"> erode window by a distance r</td>
</tr>
<tr>
  <td align="left"> <code><a href="dilate.owin.html">dilate.owin</a></code>       </td>  <td align="left"> dilate window by a distance r</td>
</tr>
<tr>
  <td align="left"> <code><a href="complement.owin.html">complement.owin</a></code>   </td>  <td align="left"> invert (swap inside and outside)</td>
</tr>
<tr>
  <td align="left"> <code><a href="rotate.html">rotate</a></code> </td>  <td align="left"> rotate window  </td>
</tr>
<tr>
  <td align="left"> <code><a href="shift.html">shift</a> </code> </td>  <td align="left"> translate window  </td>
</tr>
<tr>
  <td align="left"> <code><a href="affine.html">affine</a></code> </td>  <td align="left"> apply affine transformation </td>
</tr>
</table>

<p>
<B>Digital approximations:</B>
</p>

<table summary="Rd table">
<tr>
  <td align="left"><code><a href="as.mask.html">as.mask</a></code>   </td>  <td align="left"> Make a discrete pixel approximation of a given window </td>
</tr>
<tr>
  <td align="left"> <code><a href="nearest.raster.point.html">nearest.raster.point</a></code> </td>  <td align="left"> map continuous coordinates to raster locations</td>
</tr>
<tr>
  <td align="left"> <code><a href="raster.x.html">raster.x</a></code> </td>  <td align="left"> raster x coordinates </td>
</tr>
<tr>
  <td align="left"> <code><a href="raster.x.html">raster.y</a></code> </td>  <td align="left"> raster y coordinates  </td>
</tr>
</table>
<p>
See <code><a href="spatstat.options.html">spatstat.options</a></code> to control the approximation
</p>
<p>
<B>Geometrical computations with windows:</B>
</p>

<table summary="Rd table">
<tr>
  <td align="left"><code><a href="intersect.owin.html">intersect.owin</a></code>    </td>  <td align="left">    intersection of two windows</td>
</tr>
<tr>
  <td align="left"> <code><a href="intersect.owin.html">union.owin</a></code>        </td>  <td align="left">    union of two windows</td>
</tr>
<tr>
  <td align="left"> <code><a href="inside.owin.html">inside.owin</a></code>       </td>  <td align="left">    determine whether a point is inside a window</td>
</tr>
<tr>
  <td align="left"> <code><a href="area.owin.html">area.owin</a></code> </td>  <td align="left">    compute window's area </td>
</tr>
<tr>
  <td align="left"> <code><a href="diameter.html">diameter</a></code>  </td>  <td align="left">    compute window frame's diameter</td>
</tr>
<tr>
  <td align="left"> <code><a href="eroded.areas.html">eroded.areas</a></code>      </td>  <td align="left">    compute areas of eroded windows</td>
</tr>
<tr>
  <td align="left"> <code><a href="bdist.points.html">bdist.points</a></code>      </td>  <td align="left">    compute distances from data points to window boundary </td>
</tr>
<tr>
  <td align="left"> <code><a href="bdist.pixels.html">bdist.pixels</a></code>      </td>  <td align="left">    compute distances from all pixels to window boundary </td>
</tr>
<tr>
  <td align="left"> <code><a href="distmap.owin.html">distmap.owin</a></code>      </td>  <td align="left">    distance transform image </td>
</tr>
<tr>
  <td align="left"> <code><a href="centroid.owin.html">centroid.owin</a></code>     </td>  <td align="left"> compute centroid (centre of mass) of window</td>
</tr>
<tr>
  <td align="left"> <code><a href="is.subset.owin.html">is.subset.owin</a></code>    </td>  <td align="left"> determine whether one window contains another  </td>
</tr>
</table>

<p>
<B>Pixel images:</B>
An object of class <code>"im"</code> represents a pixel image. 
Such objects are returned by some of the functions in
<STRONG>spatstat</STRONG> including <code><a href="Kmeasure.html">Kmeasure</a></code>,
<code><a href="setcov.html">setcov</a></code> and <code><a href="density.ppp.html">density.ppp</a></code>. 
<table summary="Rd table">
<tr>
  <td align="left"><code><a href="im.html">im</a></code> </td>  <td align="left"> create a pixel image</td>
</tr>
<tr>
  <td align="left"> <code><a href="as.im.html">as.im</a></code> </td>  <td align="left"> convert other data to a pixel image</td>
</tr>
<tr>
  <td align="left"> <code><a href="as.matrix.im.html">as.matrix.im</a></code> </td>  <td align="left"> convert pixel image to matrix</td>
</tr>
<tr>
  <td align="left"> <code><a href="plot.im.html">plot.im</a></code>   </td>  <td align="left">    plot a pixel image on screen as a digital image</td>
</tr>
<tr>
  <td align="left"> <code><a href="contour.im.html">contour.im</a></code>        </td>  <td align="left"> draw contours of a pixel image </td>
</tr>
<tr>
  <td align="left"> <code><a href="persp.im.html">persp.im</a></code>  </td>  <td align="left"> draw perspective plot of a pixel image </td>
</tr>
<tr>
  <td align="left"> <code><a href="subset.im.html">[.im</a></code>      </td>  <td align="left"> extract subset of pixel image</td>
</tr>
<tr>
  <td align="left"> <code><a href="shift.im.html">shift.im</a></code> </td>  <td align="left"> apply vector shift to pixel image </td>
</tr>
<tr>
  <td align="left"> <code>X</code>        </td>  <td align="left">    print very basic information about image <code>X</code></td>
</tr>
<tr>
  <td align="left"> <code><a href="../../Zelig/html/summary.zelig.html">summary</a>(X)</code> </td>  <td align="left">   summary of image <code>X</code> </td>
</tr>
<tr>
  <td align="left"> <code><a href="hist.im.html">hist.im</a></code> </td>  <td align="left">      histogram of image </td>
</tr>
<tr>
  <td align="left"> <code><a href="mean.im.html">mean.im</a></code> </td>  <td align="left">      mean pixel value of image  </td>
</tr>
<tr>
  <td align="left"> <code><a href="quantile.im.html">quantile.im</a></code> </td>  <td align="left">  quantiles of image  </td>
</tr>
<tr>
  <td align="left"> <code><a href="cut.im.html">cut.im</a></code> </td>  <td align="left">       convert numeric image to factor image </td>
</tr>
<tr>
  <td align="left"> <code><a href="is.im.html">is.im</a></code> </td>  <td align="left"> test whether an object is a pixel image</td>
</tr>
<tr>
  <td align="left"> <code><a href="compatible.im.html">compatible.im</a></code> </td>  <td align="left"> test whether two images have compatible dimensions </td>
</tr>
<tr>
  <td align="left"> <code><a href="eval.im.html">eval.im</a></code> </td>  <td align="left"> evaluate any expression involving images</td>
</tr>
<tr>
  <td align="left"> <code><a href="levelset.html">levelset</a></code> </td>  <td align="left"> level set of an image</td>
</tr>
<tr>
  <td align="left"> <code><a href="solutionset.html">solutionset</a></code> </td>  <td align="left"> region where an expression is true </td>
</tr>
</table>

<p>
<B>Line segment patterns</B>
</p>
<p>
An object of class <code>"psp"</code> represents a pattern of line
segments.
<table summary="Rd table">
<tr>
  <td align="left"><code><a href="psp.html">psp</a></code> </td>  <td align="left"> create a line segment pattern </td>
</tr>
<tr>
  <td align="left"> <code><a href="as.psp.html">as.psp</a></code> </td>  <td align="left"> convert other data into a line segment pattern </td>
</tr>
<tr>
  <td align="left"> <code><a href="plot.psp.html">plot.psp</a></code> </td>  <td align="left"> plot a line segment pattern </td>
</tr>
<tr>
  <td align="left"> <code><a href="print.psp.html">print.psp</a></code> </td>  <td align="left"> print basic information </td>
</tr>
<tr>
  <td align="left"> <code><a href="summary.psp.html">summary.psp</a></code> </td>  <td align="left"> print summary information </td>
</tr>
<tr>
  <td align="left"> <code><a href="subset.psp.html">subset.psp</a></code> </td>  <td align="left"> </td>
</tr>
<tr>
  <td align="left"> <code><a href="subset.psp.html">[.psp</a></code> </td>  <td align="left"> extract a subset of a line segment pattern </td>
</tr>
<tr>
  <td align="left"> <code><a href="midpoints.psp.html">midpoints.psp</a></code> </td>  <td align="left"> compute the midpoints of line segments </td>
</tr>
<tr>
  <td align="left"> <code><a href="endpoints.psp.html">endpoints.psp</a></code> </td>  <td align="left"> extract the endpoints of line segments </td>
</tr>
<tr>
  <td align="left"> <code><a href="lengths.psp.html">lengths.psp</a></code> </td>  <td align="left"> compute the lengths of line segments </td>
</tr>
<tr>
  <td align="left"> <code><a href="angles.psp.html">angles.psp</a></code> </td>  <td align="left"> compute the orientation angles of line segments </td>
</tr>
<tr>
  <td align="left"> <code><a href="rotate.psp.html">rotate.psp</a></code> </td>  <td align="left"> rotate a line segment pattern </td>
</tr>
<tr>
  <td align="left">       <code><a href="shift.psp.html">shift.psp</a></code> </td>  <td align="left"> shift a line segment pattern </td>
</tr>
<tr>
  <td align="left">       <code><a href="affine.psp.html">affine.psp</a></code> </td>  <td align="left"> apply an affine transformation </td>
</tr>
<tr>
  <td align="left">       <code><a href="distmap.psp.html">distmap.psp</a></code> </td>  <td align="left"> compute the distance map of a line segment pattern </td>
</tr>
<tr>
  <td align="left"> <code><a href="density.psp.html">density.psp</a></code> </td>  <td align="left"> kernel smoothing of line segments</td>
</tr>
<tr>
  <td align="left"> <code><a href="selfcrossing.psp.html">selfcrossing.psp</a></code> </td>  <td align="left"> find crossing points between line segments </td>
</tr>
<tr>
  <td align="left"> <code><a href="crossing.psp.html">crossing.psp</a></code> </td>  <td align="left"> find crossing points between two line segment patterns  </td>
</tr>
</table>


<h3>II. EXPLORATORY DATA ANALYSIS</h3>

<p>
<B>Inspection of data:</B>
<table summary="Rd table">
<tr>
  <td align="left"><code><a href="../../Zelig/html/summary.zelig.html">summary</a>(X)</code> </td>  <td align="left"> print useful summary of point pattern <code>X</code></td>
</tr>
<tr>
  <td align="left"> <code>X</code> </td>  <td align="left"> print basic description of point pattern <code>X</code>  </td>
</tr>
<tr>
  <td align="left"> <code>any(duplicated(X))</code> </td>  <td align="left"> check for duplicated points in pattern <code>X</code> </td>
</tr>
</table>

<p>
<B>Summary statistics for a point pattern:</B>
<table summary="Rd table">
<tr>
  <td align="left"><code><a href="quadratcount.html">quadratcount</a></code> </td>  <td align="left"> Quadrat counts </td>
</tr>
<tr>
  <td align="left"> <code><a href="Fest.html">Fest</a></code> </td>  <td align="left"> empty space function <i>F</i> </td>
</tr>
<tr>
  <td align="left"> <code><a href="Gest.html">Gest</a></code> </td>  <td align="left"> nearest neighbour distribution function <i>G</i> </td>
</tr>
<tr>
  <td align="left"> <code><a href="Kest.html">Kest</a></code> </td>  <td align="left"> Ripley's <i>K</i>-function</td>
</tr>
<tr>
  <td align="left"> <code><a href="Jest.html">Jest</a></code> </td>  <td align="left"> <i>J</i>-function <i>J = (1-G)/(1-F)</i> </td>
</tr>
<tr>
  <td align="left"> <code><a href="pcf.html">pcf</a></code> </td>  <td align="left">      pair correlation function </td>
</tr>
<tr>
  <td align="left"> <code><a href="Kinhom.html">Kinhom</a></code> </td>  <td align="left"> <i>K</i> for inhomogeneous point patterns </td>
</tr>
<tr>
  <td align="left"> <code><a href="Kest.fft.html">Kest.fft</a></code> </td>  <td align="left"> fast <i>K</i>-function using FFT for large datasets </td>
</tr>
<tr>
  <td align="left"> <code><a href="Kmeasure.html">Kmeasure</a></code> </td>  <td align="left"> reduced second moment measure </td>
</tr>
<tr>
  <td align="left"> <code><a href="allstats.html">allstats</a></code> </td>  <td align="left"> all four functions <i>F</i>, <i>G</i>, <i>J</i>, <i>K</i> </td>
</tr>
<tr>
  <td align="left"> <code><a href="envelope.html">envelope</a></code> </td>  <td align="left"> simulation envelopes for a summary function </td>
</tr>
</table>

<p>
Related facilities:
<table summary="Rd table">
<tr>
  <td align="left"><code><a href="plot.fv.html">plot.fv</a></code> </td>  <td align="left"> plot a summary function</td>
</tr>
<tr>
  <td align="left"> <code><a href="eval.fv.html">eval.fv</a></code> </td>  <td align="left"> evaluate any expression involving summary functions</td>
</tr>
<tr>
  <td align="left"> <code><a href="nndist.html">nndist</a></code> </td>  <td align="left"> nearest neighbour distances </td>
</tr>
<tr>
  <td align="left"> <code><a href="nnwhich.html">nnwhich</a></code> </td>  <td align="left"> find nearest neighbours </td>
</tr>
<tr>
  <td align="left"> <code><a href="pairdist.html">pairdist</a></code> </td>  <td align="left"> distances between all pairs of points</td>
</tr>
<tr>
  <td align="left"> <code><a href="crossdist.html">crossdist</a></code> </td>  <td align="left"> distances between points in two patterns</td>
</tr>
<tr>
  <td align="left"> <code><a href="nncross.html">nncross</a></code> </td>  <td align="left"> nearest neighbours between two point patterns </td>
</tr>
<tr>
  <td align="left"> <code><a href="internal.html">exactdt</a></code> </td>  <td align="left"> distance from any location to nearest data point</td>
</tr>
<tr>
  <td align="left">  <code><a href="distmap.html">distmap</a></code> </td>  <td align="left"> distance map image</td>
</tr>
<tr>
  <td align="left"> <code><a href="density.ppp.html">density.ppp</a></code> </td>  <td align="left"> kernel smoothed density </td>
</tr>
</table>

<p>
<B>Summary statistics for a multitype point pattern:</B>
A multitype point pattern is represented by an object <code>X</code>
of class <code>"ppp"</code> with a component <code>X$marks</code> which is a factor. 
<table summary="Rd table">
<tr>
  <td align="left"><code><a href="Gcross.html">Gcross</a>,<a href="Gdot.html">Gdot</a>,<a href="Gmulti.html">Gmulti</a></code> </td>  <td align="left"> multitype nearest neighbour distributions  <i>Gij, Gi.</i> </td>
</tr>
<tr>
  <td align="left"> <code><a href="Kcross.html">Kcross</a>,<a href="Kdot.html">Kdot</a>, <a href="Kmulti.html">Kmulti</a></code> </td>  <td align="left"> multitype <i>K</i>-functions  <i>Kij, Ki.</i> </td>
</tr>
<tr>
  <td align="left"> <code><a href="Jcross.html">Jcross</a>,<a href="Jdot.html">Jdot</a>,<a href="Jmulti.html">Jmulti</a></code> </td>  <td align="left"> multitype <i>J</i>-functions <i>Jij,Ji.</i> </td>
</tr>
<tr>
  <td align="left"> <code><a href="alltypes.html">alltypes</a></code> </td>  <td align="left">  estimates of the above for all <i>i,j</i> pairs </td>
</tr>
<tr>
  <td align="left"> <code><a href="Iest.html">Iest</a></code> </td>  <td align="left">  multitype <i>I</i>-function</td>
</tr>
<tr>
  <td align="left"> <code><a href="Kcross.inhom.html">Kcross.inhom</a>,<a href="Kdot.inhom.html">Kdot.inhom</a></code> </td>  <td align="left"> inhomogeneous counterparts of <code>Kcross</code>, <code>Kdot</code> </td>
</tr>
</table>

<p>
<B>Summary statistics for a marked point pattern:</B>
A marked point pattern is represented by an object <code>X</code>
of class <code>"ppp"</code> with a component <code>X$marks</code>.
The entries in the vector <code>X$marks</code> may be numeric, complex,
string or any other atomic type.
<table summary="Rd table">
<tr>
  <td align="left"><code><a href="markcorr.html">markcorr</a></code> </td>  <td align="left"> mark correlation function </td>
</tr>
<tr>
  <td align="left"> <code><a href="Gmulti.html">Gmulti</a></code> </td>  <td align="left"> multitype nearest neighbour distribution </td>
</tr>
<tr>
  <td align="left"> <code><a href="Kmulti.html">Kmulti</a></code> </td>  <td align="left"> multitype <i>K</i>-function </td>
</tr>
<tr>
  <td align="left"> <code><a href="Jmulti.html">Jmulti</a></code> </td>  <td align="left"> multitype <i>J</i>-function  </td>
</tr>
</table>
<p>
Alternatively use <code><a href="cut.ppp.html">cut.ppp</a></code> to convert a marked point pattern
to a multitype point pattern.
</p>
<p>
<B>Programming tools:</B>
<table summary="Rd table">
<tr>
  <td align="left"><code><a href="applynbd.html">applynbd</a></code> </td>  <td align="left"> apply function to every neighbourhood</td>
</tr>
<tr>
  <td align="left"> </td>  <td align="left"> in a point pattern </td>
</tr>
<tr>
  <td align="left"> <code><a href="pppdist.html">pppdist</a></code> </td>  <td align="left"> find the optimal match between two point patterns </td>
</tr>
</table>


<h3>III. MODEL FITTING (CLUSTER MODELS)</h3>

<p>
Several kinds of clustered point process models can be fitted
using the Method of Minimum Contrast.
</p>

<table summary="Rd table">
<tr>
  <td align="left"><code><a href="thomas.estK.html">thomas.estK</a></code> </td>  <td align="left"> fit the Thomas process model </td>
</tr>
<tr>
  <td align="left"> <code><a href="matclust.estK.html">matclust.estK</a></code> </td>  <td align="left"> fit the Matern Cluster process model </td>
</tr>
<tr>
  <td align="left"> <code><a href="lgcp.estK.html">lgcp.estK</a></code> </td>  <td align="left"> fit a log-Gaussian Cox process model</td>
</tr>
<tr>
  <td align="left"> <code><a href="mincontrast.html">mincontrast</a></code> </td>  <td align="left"> general algorithm for fitting models </td>
</tr>
<tr>
  <td align="left"> </td>  <td align="left"> by the method of minimum contrast  </td>
</tr>
</table>

<p>
The Thomas and Matern models can also be simulated,
using <code><a href="rThomas.html">rThomas</a></code> and <code><a href="rMatClust.html">rMatClust</a></code> respectively.
</p>


<h3>IV. MODEL FITTING (GIBBS MODELS)</h3>

<p>
For a detailed explanation of how to fit models to point pattern data
using <STRONG>spatstat</STRONG>, see Baddeley and Turner (2005b).
</p>
<p>
<B>To fit a Gibbs point process model:</B>
</p>
<p>
Model fitting in <STRONG>spatstat</STRONG> is performed mainly by the function
<code><a href="ppm.html">ppm</a></code>. Its result is an object of class <code>"ppm"</code>. 
</p>
<p>
<B>Manipulating the fitted model:</B>
</p>

<table summary="Rd table">
<tr>
  <td align="left"><code><a href="plot.ppm.html">plot.ppm</a></code> </td>  <td align="left">                 Plot the fitted model</td>
</tr>
<tr>
  <td align="left"> <code><a href="predict.ppm.html">predict.ppm</a></code> </td>  <td align="left">              Compute the spatial trend </td>
</tr>
<tr>
  <td align="left"> </td>  <td align="left">        and conditional intensity</td>
</tr>
<tr>
  <td align="left"> </td>  <td align="left">        of the fitted point process model </td>
</tr>
<tr>
  <td align="left"> <code><a href="coef.ppm.html">coef.ppm</a></code> </td>  <td align="left"> Extract the fitted model coefficients</td>
</tr>
<tr>
  <td align="left"> <code><a href="fitted.ppm.html">fitted.ppm</a></code> </td>  <td align="left"> Compute fitted conditional intensity at quadrature points </td>
</tr>
<tr>
  <td align="left"> <code><a href="update.ppm.html">update.ppm</a></code> </td>  <td align="left"> Update the fit </td>
</tr>
<tr>
  <td align="left"> <code><a href="vcov.ppm.html">vcov.ppm</a></code> </td>  <td align="left"> Variance-covariance matrix of estimates</td>
</tr>
<tr>
  <td align="left"> <code><a href="rmh.ppm.html">rmh.ppm</a></code> </td>  <td align="left"> Simulate from fitted model  </td>
</tr>
<tr>
  <td align="left"> <code><a href="print.ppm.html">print.ppm</a></code> </td>  <td align="left"> Print basic information about a fitted model</td>
</tr>
<tr>
  <td align="left"> <code><a href="summary.ppm.html">summary.ppm</a></code> </td>  <td align="left"> Summarise a fitted model</td>
</tr>
<tr>
  <td align="left"> <code><a href="anova.ppm.html">anova.ppm</a></code> </td>  <td align="left"> Analysis of deviance </td>
</tr>
</table>
<p>
See <code><a href="spatstat.options.html">spatstat.options</a></code> to control plotting of fitted model.
</p>
<p>
<B>To specify a point process model:</B>
</p>
<p>
The first order ``trend'' of the model is written as an <code>R</code>
language formula.
</p>

<table summary="Rd table">
<tr>
  <td align="left"><code>~1</code>  </td>  <td align="left"> No trend (stationary) </td>
</tr>
<tr>
  <td align="left"> <code>~x</code>   </td>  <td align="left"> First order term  <i>&lambda;(x,y) = exp(&alpha; + &beta; x)</i> </td>
</tr>
<tr>
  <td align="left"> </td>  <td align="left"> where <i>x,y</i> are Cartesian coordinates </td>
</tr>
<tr>
  <td align="left"> <code>~polynom(x,y,3)</code>  </td>  <td align="left"> Log-cubic polynomial trend  </td>
</tr>
<tr>
  <td align="left"> <code>~harmonic(x,y,2)</code>  </td>  <td align="left"> Log-harmonic polynomial trend  </td>
</tr>
</table>

<p>
The higher order (``interaction'') components are described by
an object of class <code>"interact"</code>. Such objects are created by:
<table summary="Rd table">
<tr>
  <td align="left"><code><a href="Poisson.html">Poisson</a>()</code> </td>  <td align="left">                the Poisson point process</td>
</tr>
<tr>
  <td align="left"> <code><a href="Strauss.html">Strauss</a>()</code> </td>  <td align="left">                the Strauss process </td>
</tr>
<tr>
  <td align="left"> <code><a href="StraussHard.html">StraussHard</a>()</code> </td>  <td align="left">            the Strauss/hard core point process</td>
</tr>
<tr>
  <td align="left"> <code><a href="Softcore.html">Softcore</a>()</code> </td>  <td align="left">               pairwise interaction, soft core potential</td>
</tr>
<tr>
  <td align="left"> <code><a href="PairPiece.html">PairPiece</a>()</code> </td>  <td align="left">              pairwise interaction, piecewise constant </td>
</tr>
<tr>
  <td align="left"> <code><a href="DiggleGratton.html">DiggleGratton</a>() </code> </td>  <td align="left"> Diggle-Gratton potential </td>
</tr>
<tr>
  <td align="left"> <code><a href="LennardJones.html">LennardJones</a>() </code> </td>  <td align="left"> Lennard-Jones potential </td>
</tr>
<tr>
  <td align="left"> <code><a href="Pairwise.html">Pairwise</a>()</code> </td>  <td align="left">       pairwise interaction, user-supplied potential</td>
</tr>
<tr>
  <td align="left"> <code><a href="Geyer.html">Geyer</a>()</code>        </td>  <td align="left"> Geyer's saturation process</td>
</tr>
<tr>
  <td align="left"> <code><a href="Saturated.html">Saturated</a>()</code> </td>  <td align="left">      Saturated pair model, user-supplied potential</td>
</tr>
<tr>
  <td align="left"> <code><a href="OrdThresh.html">OrdThresh</a>()</code> </td>  <td align="left">              Ord process, threshold potential</td>
</tr>
<tr>
  <td align="left"> <code><a href="Ord.html">Ord</a>()</code> </td>  <td align="left">                    Ord model, user-supplied potential </td>
</tr>
<tr>
  <td align="left"> <code><a href="MultiStrauss.html">MultiStrauss</a>()</code> </td>  <td align="left">           multitype Strauss process </td>
</tr>
<tr>
  <td align="left"> <code><a href="MultiStraussHard.html">MultiStraussHard</a>()</code> </td>  <td align="left">       multitype Strauss/hard core process  </td>
</tr>
</table>

<p>
<B>Finer control over model fitting:</B>
</p>
<p>
A quadrature scheme is represented by an object of
class <code>"quad"</code>.
</p>

<table summary="Rd table">
<tr>
  <td align="left"><code><a href="quadscheme.html">quadscheme</a></code> </td>  <td align="left"> generate a Berman-Turner quadrature scheme</td>
</tr>
<tr>
  <td align="left"> </td>  <td align="left">        for use by <code>ppm </code> </td>
</tr>
<tr>
  <td align="left"> <code><a href="default.dummy.html">default.dummy</a></code> </td>  <td align="left"> default pattern of dummy points </td>
</tr>
<tr>
  <td align="left"> <code><a href="gridcentres.html">gridcentres</a></code> </td>  <td align="left"> dummy points in a rectangular grid </td>
</tr>
<tr>
  <td align="left"> <code><a href="rstrat.html">rstrat</a></code> </td>  <td align="left"> stratified random dummy pattern </td>
</tr>
<tr>
  <td align="left"> <code><a href="spokes.html">spokes</a></code> </td>  <td align="left"> radial pattern of dummy points  </td>
</tr>
<tr>
  <td align="left"> <code><a href="corners.html">corners</a></code> </td>  <td align="left"> dummy points at corners of the window  </td>
</tr>
<tr>
  <td align="left"> <code><a href="gridweights.html">gridweights</a></code> </td>  <td align="left"> quadrature weights by the grid-counting rule  </td>
</tr>
<tr>
  <td align="left"> <code><a href="dirichlet.weights.html">dirichlet.weights</a></code> </td>  <td align="left"> quadrature weights are Dirichlet tile areas </td>
</tr>
<tr>
  <td align="left"> <code>plot(Q)</code> </td>  <td align="left"> plot quadrature scheme <code>Q</code></td>
</tr>
<tr>
  <td align="left"> <code>print(Q)</code> </td>  <td align="left"> print basic information about quadrature scheme <code>Q</code></td>
</tr>
<tr>
  <td align="left"> <code><a href="../../Zelig/html/summary.zelig.html">summary</a>(Q)</code> </td>  <td align="left"> summary of quadrature scheme <code>Q</code> </td>
</tr>
</table>

<p>
<B>Simulation and goodness-of-fit for fitted models:</B>
</p>

<table summary="Rd table">
<tr>
  <td align="left"><code><a href="rmh.ppm.html">rmh.ppm</a></code> </td>  <td align="left"> simulate realisations of a fitted model </td>
</tr>
<tr>
  <td align="left"> <code><a href="envelope.html">envelope</a></code> </td>  <td align="left"> compute simulation envelopes for a fitted model  </td>
</tr>
</table>


<h3>V. TESTS AND DIAGNOSTICS</h3>

<p>
<B>Classical hypothesis tests:</B>
</p>

<table summary="Rd table">
<tr>
  <td align="left"><code><a href="quadrat.test.html">quadrat.test</a></code> </td>  <td align="left"> <i>chi^2</i> goodness-of-fit test on quadrat counts </td>
</tr>
<tr>
  <td align="left"> <code><a href="envelope.html">envelope</a></code> </td>  <td align="left"> critical envelope for Monte Carlo test of goodness-of-fit </td>
</tr>
<tr>
  <td align="left"> <code><a href="anova.ppm.html">anova.ppm</a></code> </td>  <td align="left"> Analysis of Deviance for point process models  </td>
</tr>
</table>

<p>
<B>Diagnostic plots:</B>
</p>
<p>
Residuals for a fitted point process model, and diagnostic plots
based on the residuals, were introduced in Baddeley et al (2005).
</p>
<p>
Type <code>demo(diagnose)</code>
for a demonstration of the diagnostics features.
</p>

<table summary="Rd table">
<tr>
  <td align="left"><code><a href="diagnose.ppm.html">diagnose.ppm</a></code> </td>  <td align="left"> diagnostic plots for spatial trend</td>
</tr>
<tr>
  <td align="left"> <code><a href="qqplot.ppm.html">qqplot.ppm</a></code> </td>  <td align="left"> diagnostic plot for interpoint interaction</td>
</tr>
<tr>
  <td align="left"> <code><a href="residualspaper.html">residualspaper</a></code> </td>  <td align="left"> examples from Baddeley et al (2005) </td>
</tr>
</table>


<h3>VI. DOCUMENTATION</h3>

<p>
The online manual entries are quite detailed and should be consulted
first for information about a particular function.
</p>
<p>
The paper by Baddeley and Turner (2005a) describes the package.
Baddeley and Turner (2005b) is a more detailed explanation of
how to fit point process models to data.
</p>
<p>
Type <code>citation("spatstat")</code> to get these references.
</p>


<h3>Licence</h3>

<p>
This library and its documentation are usable under the terms of the "GNU 
General Public License", a copy of which is distributed with the package.
</p>


<h3>Acknowledgements</h3>

<p>
Marie-Colette van Lieshout, Kasper Klitgaard Berthelsen
and Dominic Schuhmacher made substantial contributions of code.
Additional contributions by Colin Beale, Brad Biggerstaff, Florent Bonneu,
Jianbao Chen, Y.C. Chin, Peter Diggle, Stephen Eglen,
Agnes Gault, Marc Genton, Pavel Grabarnik, C. Graf, Ute Hahn, Mandy Hering, 
Martin Bogsted Hansen, Martin Hazelton, Kurt Hornik, Robert John-Chandran,
Jorge Mateu, Jesper Moller, Linda Stougaard Nielsen, Evgeni Parilov,
Matt Reiter, Brian Ripley, Barry Rowlingson, Aila Sarkka, Katja Schladitz,
Bryan Scott, Malte Spiess, Mark Stevenson, P. Surovy, Berwin Turlach, 
Andrew van Burgel and Selene Wong.
</p>


<h3>Author(s)</h3>

<p>
Adrian Baddeley
<a href="mailto:adrian@maths.uwa.edu.au">adrian@maths.uwa.edu.au</a>
<a href="http://www.maths.uwa.edu.au/~adrian/">http://www.maths.uwa.edu.au/~adrian/</a>
and Rolf Turner
<a href="mailto:rolf@math.unb.ca">rolf@math.unb.ca</a>
<a href="http://www.math.unb.ca/~rolf">http://www.math.unb.ca/~rolf</a>
</p>


<h3>References</h3>

<p>
Baddeley, A. and Turner, R. (2005a)
Spatstat: an R package for analyzing spatial point patterns.
<EM>Journal of Statistical Software</EM> <B>12</B>:6, 1&ndash;42.
URL: <code>www.jstatsoft.org</code>, ISSN: 1548-7660.
</p>
<p>
Baddeley, A. and Turner, R. (2005b)
Modelling spatial point patterns in R.
In: A. Baddeley, P. Gregori, J. Mateu, R. Stoica, and D. Stoyan,
editors, <EM>Case Studies in Spatial Point Pattern Modelling</EM>,
Lecture Notes in Statistics number 185. Pages 23&ndash;74.
Springer-Verlag, New York, 2006. 
ISBN: 0-387-28311-0.
</p>
<p>
Baddeley, A., Turner, R., Moller, J. and Hazelton, M. (2005)
Residual analysis for spatial point processes.
<EM>Journal of the Royal Statistical Society, Series B</EM>
<B>67</B>, 617&ndash;666.
</p>



<hr><div align="center">[Package <em>spatstat</em> version 1.10-3 <a href="00Index.html">Index]</a></div>

</body></html>
