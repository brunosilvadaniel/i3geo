<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>R: Divide Point Pattern into Sub-patterns</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../R.css">
</head><body>

<table width="100%" summary="page for split.ppp {spatstat}"><tr><td>split.ppp {spatstat}</td><td align="right">R Documentation</td></tr></table>
<h2>Divide Point Pattern into Sub-patterns</h2>


<h3>Description</h3>

<p>
Divides a point pattern into several sub-patterns,
according to their marks, or according to any user-specified grouping.
</p>


<h3>Usage</h3>

<pre>
  ## S3 method for class 'ppp':
  split(x, f = marks(x), drop=FALSE, un=NULL, ...)
  ## S3 method for class 'ppp':
  split(x, f = marks(x), drop=FALSE, un=missing(f), ...) &lt;- value
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
A two-dimensional point pattern.
An object of class <code>"ppp"</code>.
</td></tr>
<tr valign="top"><td><code>f</code></td>
<td>
Factor determining the grouping. 
</td></tr>
<tr valign="top"><td><code>drop</code></td>
<td>
Logical. Determines whether empty groups will
be deleted.
</td></tr>
<tr valign="top"><td><code>un</code></td>
<td>
Logical. Determines whether subpatterns will be unmarked
(i.e. whether marks will be removed from the points in each
subpattern). 
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
Other arguments are ignored.
</td></tr>
<tr valign="top"><td><code>value</code></td>
<td>
List of point patterns.
</td></tr>
</table>

<h3>Details</h3>

<p>
The function <code>split.ppp</code>
divides up the points of the point pattern <code>x</code>
into several sub-patterns according to the levels of the factor
<code>f</code>. The result is a list of point patterns, one for each
level of <code>f</code>.
</p>
<p>
If <code>f</code> is present, it must be a factor, and its length
must equal the number of points in <code>x</code>. The levels of <code>f</code>
determine the destination of each point in <code>x</code>.
The <code>i</code>th point of <code>x</code> will be placed in the sub-pattern
<code>split.ppp(x)$l</code> where <code>l = f[i]</code>.
</p>
<p>
If <code>f</code> is missing, then <code>x</code> must be a multitype point pattern
(a marked point pattern whose marks vector is a factor).
Then the effect is that the points of each type
are separated into different point patterns.
</p>
<p>
Some of the sub-patterns created by the split
may be empty. If <code>drop=TRUE</code>, then empty sub-patterns will
be deleted from the list. If <code>drop=FALSE</code> then they are retained.
</p>
<p>
The argument <code>un</code> determines how to handle marks 
in the case where <code>x</code> is a marked point pattern.
If <code>un=TRUE</code> then the marks of the 
points will be discarded when they are split into groups,
while if <code>un=FALSE</code> then the marks will be retained.
</p>
<p>
The result of <code>split.ppp</code> has class <code>"splitppp"</code>
and can be plotted using <code><a href="plot.splitppp.html">plot.splitppp</a></code>.
</p>
<p>
The assignment function <code>split&lt;-.ppp</code> 
updates the point pattern <code>x</code> so that
it satisfies <code>split(x, f, drop, un) = value</code>. The argument <code>value</code>
is expected to be a list of point patterns, one for each level of
<code>f</code>. These point patterns are expected to be compatible in the sense
that they all have the same window, and either they are all unmarked
or they all have marks of the same kind. 
</p>
<p>
Splitting can also be undone by the function <code><a href="superimpose.html">superimpose</a></code>.
</p>


<h3>Value</h3>

<p>
The value of <code>split.ppp</code> is a list of point patterns.
The components of the list are named by the levels of <code>f</code>.
<br>
The assignment form <code>split&lt;-.ppp</code> returns the updated
point pattern <code>x</code>.</p>

<h3>Author(s)</h3>

<p>
Adrian Baddeley
<a href="mailto:adrian@maths.uwa.edu.au">adrian@maths.uwa.edu.au</a>
<a href="http://www.maths.uwa.edu.au/~adrian/">http://www.maths.uwa.edu.au/~adrian/</a>
and Rolf Turner
<a href="mailto:rolf@math.unb.ca">rolf@math.unb.ca</a>
<a href="http://www.math.unb.ca/~rolf">http://www.math.unb.ca/~rolf</a>
</p>


<h3>See Also</h3>

<p>
<code><a href="cut.ppp.html">cut.ppp</a></code>,
<code><a href="plot.splitppp.html">plot.splitppp</a></code>,
<code><a href="superimpose.html">superimpose</a></code>,
<code><a href="ppp.object.html">ppp.object</a></code>
</p>


<h3>Examples</h3>

<pre>

# Multitype point pattern: separate into types
 data(amacrine)
 u &lt;- split(amacrine)

# plot them
 plot(split(amacrine))

# the following are equivalent:
 amon &lt;- split(amacrine)$on
 amon &lt;- unmark(amacrine[amacrine$marks == "on"])
   
# the following are equivalent:
 amon &lt;- split(amacrine, un=FALSE)$on
 amon &lt;- amacrine[amacrine$marks == "on"]
   
# Scramble the locations of the 'on' cells
 u &lt;- split(amacrine)
 u$on &lt;- runifpoint(amon$n, amon$window)
 split(amacrine) &lt;- u

# Point pattern with continuous marks
 data(longleaf)
 
 # cut the range of tree diameters into three intervals
 long3 &lt;- cut.ppp(longleaf, 3)
 # now split them
 long3split &lt;- split(long3)

# Unmarked point pattern
  data(swedishpines)
# cut &amp; split according to nearest neighbour distance
  f &lt;- cut(nndist(swedishpines), 3)
  u &lt;- split(swedishpines, f)
</pre>



<hr><div align="center">[Package <em>spatstat</em> version 1.10-3 <a href="00Index.html">Index]</a></div>

</body></html>
